<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>toy-rpc Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="03_define_service.html"><strong aria-hidden="true">3.</strong> Define Service</a></li><li class="chapter-item expanded "><a href="04_server.html"><strong aria-hidden="true">4.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04a_async_std.html"><strong aria-hidden="true">4.1.</strong> async-std</a></li><li class="chapter-item expanded "><a href="04b_tokio.html"><strong aria-hidden="true">4.2.</strong> tokio</a></li></ol></li><li class="chapter-item expanded "><a href="05_integration.html"><strong aria-hidden="true">5.</strong> Integration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05a_actix_web.html"><strong aria-hidden="true">5.1.</strong> actix-web</a></li><li class="chapter-item expanded "><a href="05b_tide.html"><strong aria-hidden="true">5.2.</strong> tide</a></li><li class="chapter-item expanded "><a href="05c_warp.html"><strong aria-hidden="true">5.3.</strong> warp</a></li></ol></li><li class="chapter-item expanded "><a href="06_client.html"><strong aria-hidden="true">6.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06a_cancellation.html"><strong aria-hidden="true">6.1.</strong> Cancellation</a></li><li class="chapter-item expanded "><a href="06b_timeout.html"><strong aria-hidden="true">6.2.</strong> Timeout</a></li></ol></li><li class="chapter-item expanded "><a href="07_tls.html"><strong aria-hidden="true">7.</strong> TLS Support</a></li><li class="chapter-item expanded "><a href="09_examples.html"><strong aria-hidden="true">8.</strong> Examples</a></li><li class="chapter-item expanded "><a href="10_change_log.html"><strong aria-hidden="true">9.</strong> Change Logs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">toy-rpc Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div align="center">
<!-- Crates version -->
<a href="https://crates.io/crates/toy-rpc">
<img src="https://img.shields.io/crates/v/toy-rpc.svg?style=flat" alt="Crates.io version" />
</a>
<!-- docs.rs docs -->
<a href="https://docs.rs/toy-rpc">
<img src="https://img.shields.io/badge/docs-latest-blue.svg?style=flat" alt="docs.rs docs" />
</a>
<!-- Downloads -->
<a href="https://crates.io/crates/toy-rpc">
<img src="https://img.shields.io/crates/d/toy-rpc.svg?style=flat" alt="Download" />
</a>
<a href="https://github.com/rust-secure-code/safety-dance/">
<img src="https://img.shields.io/badge/unsafe-forbidden-success.svg?style=flat" alt="Unsafe Rust forbidden" />
</a>
</div>
<p><code>toy-rpc</code> aims to be an easy-to-use <code>async</code> RPC tool that is inspired by golang's <code>net/rpc</code>'s API. 
It supports both <code>async_std</code> and <code>tokio</code> runtimes over either TCP or TLS. Integration with common HTTP server frameworks such as <code>actix_web</code>, <code>warp</code> and <code>tide</code>
are provided.</p>
<p>The overall usage and API should feel similar to that of the golang's <code>net/rpc</code> package. Some of the names are changed 
to make them sound more &quot;rusty&quot;. Because rust does not come with runtime reflection, attribute macros <code>#[export_impl]</code>
and <code>#[export_trait]</code> / <code>#[export_trait_impl]</code>, and attribute <code>#[export_method]</code> are used to mark functions &quot;exported&quot; in golang's 
<code>net/rpc</code> perspective.</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>While there are grpc implementations like <code>grpc-rs</code> and <code>tonic</code> as well as schema-free crates like <code>tarpc</code>, I didn't find 
a crate that offers the same level of ease-of-use as that of the golang's <code>net/rpc</code> package. Other than the ease-of-use,
not many async RPC crates work with both <code>async_std</code> and <code>tokio</code> runtime and could be difficult to integrate with the common
async HTTP crates (<code>actix_web</code>, <code>warp</code>, and <code>tide</code>). Thus I started working on this crate to bring something that is 
easy-to-use and supports both <code>async_std</code> and <code>tokio</code> runtimes.</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature flags</a></h2>
<p>Most of the feature flags can be put into three categories.</p>
<p>Choice of runtime and HTTP framework integration</p>
<ul>
<li><code>async_std_runtime</code>: supports usage with <code>async-std</code></li>
<li><code>tokio_runtime</code>: supports usage with <code>tokio</code></li>
<li><code>http_tide</code>: enables <code>tide</code> integration on the server side. This also enables <code>async_std_runtime</code></li>
<li><code>http_actix_web</code>: enables <code>actix-web</code> integration on the server side. This also enables <code>tokio_runtime</code></li>
<li><code>http_warp</code>: enables integration with <code>warp</code> on the server side. This also enables <code>tokio_runtime</code></li>
</ul>
<p>Choice of RPC server or client (both can be enabled at the same time)</p>
<ul>
<li><code>server</code>: enables RPC server</li>
<li><code>client</code>: enables RPC client </li>
</ul>
<p>Choice of serialization/deserialzation (only one should be enabled at a time)</p>
<ul>
<li><code>serde_bincode</code>: (default) the default codec will use <code>bincode</code>
for serialization/deserialization</li>
<li><code>serde_json</code>: the default codec will use <code>serde_json</code>
for <code>json</code> serialization/deserialization</li>
<li><code>serde_cbor</code>: the default codec will use <code>serde_cbor</code>
for serialization/deserialization</li>
<li><code>serde_rmp</code>: the default codec will use <code>rmp-serde</code>
for serialization/deserialization</li>
</ul>
<p>TLS support</p>
<ul>
<li>&quot;tls&quot;: enables TLS support</li>
</ul>
<p>Other trivial feature flags are listed below, and they are likely of no actual usage for you.</p>
<ul>
<li><code>docs</code></li>
<li><code>std</code>: <code>serde/std</code>. There is no actual usage right now.</li>
</ul>
<p>By default, only <code>serde_bincode</code> feature is enabled. 
You must enable at least one runtime feature flag and the <code>server</code> and/or <code>client</code> to have something usable.</p>
<h2 id="default-features"><a class="header" href="#default-features">Default features</a></h2>
<pre><code class="language-toml">default = [
    &quot;serde_bincode&quot;,
]
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>A simple quickstart with <code>tokio</code> runtime is shown below. More examples can be found in the <strong>Example</strong> chapter.</p>
<h2 id="initialize-new-project"><a class="header" href="#initialize-new-project">Initialize new project</a></h2>
<p><code>cargo new --lib toy_rpc_quickstart</code></p>
<h2 id="add-dependencies"><a class="header" href="#add-dependencies">Add dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;, &quot;client&quot;] }
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h2>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>In the <code>Cargo.toml</code>, you may need to specify the binaries with </p>
<pre><code class="language-toml">[[bin]]
name = &quot;server&quot;
path = &quot;src/bin/server.rs&quot;

[[bin]]
name = &quot;client&quot;
path = &quot;src/bin/client.rs&quot; 
</code></pre>
<h2 id="define-rpc-service"><a class="header" href="#define-rpc-service">Define RPC service</a></h2>
<p>In <code>src/lib.rs</code></p>
<pre><code class="language-rust noplaypen">// src/lib.rs

pub mod rpc {
    use toy_rpc::macros::export_impl;
    pub struct Echo { }
    
    #[export_impl]
    impl Echo {
        #[export_method]
        pub async fn echo_i32(&amp;self, arg: i32) -&gt; Result&lt;i32, String&gt; {
            Ok(arg)
        }
    }
}
</code></pre>
<h2 id="rpc-server"><a class="header" href="#rpc-server">RPC server</a></h2>
<p>In <code>src/bin/server.rs</code></p>
<pre><code class="language-rust noplaypen">// src/bin/server.rs

use tokio::{task, net::TcpListener};
use std::sync::Arc;
use toy_rpc::Server;

use toy_rpc_quickstart::rpc::Echo;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    
    // Creates an instance of the `Echo` service
    let echo_service = Arc::new(
        Echo { }
    );

    let server = Server::builder()
        .register(echo_service) // register service
        .build();
    let listener = TcpListener::bind(addr).await.unwrap();

    // Run the server in a separate task
    let handle = task::spawn(async move {
        println!(&quot;Starting server at {}&quot;, &amp;addr);
        server.accept(listener).await.unwrap();
    });
    handle.await.expect(&quot;Error running the RPC server&quot;);
}
</code></pre>
<h2 id="rpc-client"><a class="header" href="#rpc-client">RPC client</a></h2>
<p>In <code>src/bin/client.rs</code></p>
<pre><code class="language-rust noplaypen">use toy_rpc::Client;

// import everything including the client stub generated by the macro
use toy_rpc_quickstart::rpc::*;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let client = Client::dial(addr).await.unwrap();

    let result: i32 = client
        .echo() // calling service `Echo`
        .echo_i32(3i32) // calling RPC method `echo_i32`
        .await  
        .unwrap();
    println!(&quot;{:?}&quot;, result);

    // The above call is equivalent to
    let result: i32 = client
        .call(&quot;Echo.echo_i32&quot;, 3i32)
        .await
        .unwrap();
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="define-service"><a class="header" href="#define-service">Define Service</a></h1>
<p>There are two ways (but three attribute macros) to help you define the the RPC service.</p>
<ul>
<li>The attribute macro <code>#[export_impl]</code> can be used when the implementation and the service definition are 
located in the same file/project. The name of the <code>struct</code> will be used as the default service name with <code>#[export_impl]</code> in a case sensitive manner.</li>
<li>The attribute macros <code>#[export_trait]</code> and <code>#[export_trait_impl]</code> should be used when an abstract service definition (a <code>trait</code>) will be shared among different projects. The name of the <code>trait</code> will be used as the default service name with <code>#[export_trait]</code> in a case sensitive manner.</li>
</ul>
<p>Both <code>#[export_impl]</code> and <code>#[export_trait]</code> will generate the client stub traits/methods when the &quot;client&quot; feature flag is enabled and a runtime feature flag is enabled on <code>toy-rpc</code>.</p>
<p>Inside the <code>impl</code> block or <code>trait</code> definition block, you should then use the attribute 
<code>#[export_method]</code> to mark which method(s) should be &quot;exported&quot; as RPC method(s). 
The methods to export must meet the following criteria on the server side</p>
<ul>
<li>the method resides in an impl block marked with <code>#[export_impl]</code> or <code>#[export_trait]</code></li>
<li>the method is marked with <code>#[export_method]</code> attribute</li>
<li>the method takes one argument other than <code>&amp;self</code> and returns a <code>Result&lt;T, E&gt;</code>
<ul>
<li>the argument must implement trait <code>serde::Deserialize</code></li>
<li>the <code>Ok</code> type <code>T</code> of the result must implement trait <code>serde::Serialize</code></li>
<li>the <code>Err</code> type <code>E</code> of the result must implement trait <code>ToString</code></li>
</ul>
</li>
</ul>
<p>The method is essentially in the form</p>
<pre><code class="language-rust noplaypen">#[export_method]
async fn method_name(&amp;self, args: Req) -&gt; Result&lt;Res, ErrorMsg&gt;
where
    Req: serde::Deserialize,
    Res: serde::Serialize,
    ErrorMsg: ToString,
{
    // ...
}
</code></pre>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<p>Use the following dependencies to work with the examples below</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
toy-rpc = &quot;0.7.0-alpha.2&quot;
</code></pre>
<h3 id="export_impl"><a class="header" href="#export_impl"><code>#[export_impl]</code></a></h3>
<p>When you have both the service definition and the implementation in the same file, you can use <code>#[export_impl]</code> on the <code>impl</code> block. This will also use the name of the <code>struct</code> as the default service name.</p>
<p>File structure </p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Suppose that <em>both</em> the service definitions and implementations are placed in <code>src/lib.rs</code>.</p>
<pre><code class="language-rust noplaypen">// src/lib.rs
use toy_rpc::macros::export_impl;

pub struct Foo { }

#[export_impl] // The default service name will be &quot;Foo&quot;
impl Foo {
    // use attribute `#[export_method]` to mark which method to &quot;export&quot;
    #[export_method]
    async fn exported_method(&amp;self, args: ()) -&gt; Result&lt;String, String&gt; {
        Ok(&quot;exported method&quot;.into())
    }

    async fn not_exported_method(&amp;self, args: ()) -&gt; Result&lt;String, String&gt; {
        Ok(&quot;not exported method&quot;.into())
    }
}
</code></pre>
<p>You may also define a separate trait in <code>src/lib.rs</code> which is implemented by some <code>struct</code> in the same file.</p>
<pre><code class="language-rust noplaypen">// continuing in src/lib.rs

use async_trait::async_trait;

#[async_trait]
pub trait Arith {
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;
}

pub struct Bar { }
// implement the Arith trait for `Bar { }`and then mark the implementation as &quot;exported&quot; for RPC

#[async_trait]
// Place `#[export_impl] ` after `#[async_trait]`
#[export_impl] // The default service name will be &quot;Bar&quot;
impl Arith for Bar {
    // Only mark `add(...)` as RPC method
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    // `subtract(...)` will not be accessible from RPC calls
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }
}
</code></pre>
<p>We will continue to use this example in the <a href="https://minghuaw.github.io/toy-rpc/04_server.html">Server</a> and <a href="https://minghuaw.github.io/toy-rpc/06_client.html">Client</a> chapters.</p>
<h3 id="export_trait-and-export_trait_impl"><a class="header" href="#export_trait-and-export_trait_impl"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code></a></h3>
<p>When you want the abstract service definition to be shared but without concreate implementations, you should use <code>#[export_trait]</code> on the trait definition and <code>#[export_trait_impl]</code> on the concrete trait implementation. Please note that the default service name hence will be the name of the <code>trait</code> <strong>NOT</strong> that of the <code>struct</code>.</p>
<p>Suppose we will have three separate crates</p>
<ul>
<li><code>&quot;example-service&quot;</code> as the service definition,</li>
<li><code>&quot;example-server&quot;</code> acting as the server,</li>
<li>and <code>&quot;example-client&quot;</code> acting as the client</li>
</ul>
<p>which can also be found in the GitHub examples (<a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-service">service</a>, <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-server">server</a>, <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-client">client</a>).</p>
<p>We are going to define the RPC service just as a trait in <code>&quot;example-service&quot;</code>.</p>
<pre><code class="language-rust noplaypen">// example-service/src/lib.rs
use async_trait::async_trait;
use toy_rpc::macros::export_trait;

#[async_trait]
#[export_trait] // The default service name will be &quot;Arith&quot;
pub trait Arith {
    // let's mark both `add(...)` and `subtract(...)` as RPC method
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;

    #[export_method]
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;

    // some method that we don't want to export
    fn say_hi(&amp;self);
}
</code></pre>
<p>We will continue to use this example in the <a href="https://minghuaw.github.io/toy-rpc/04_server.html">Server</a> and <a href="https://minghuaw.github.io/toy-rpc/06_client.html">Client</a> chapters.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server"><a class="header" href="#server">Server</a></h1>
<p>The server API look straightforward and fairly close to that of golang's <code>net/rpc</code> package. First we should choose an async runtime and enable the <code>&quot;server&quot;</code> feature flag in our <code>Cargo.toml</code> file. Here, we will choose the <code>tokio</code> runtime be enabling the <code>&quot;tokio_runtime&quot;</code> feature flag.</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;] }
</code></pre>
<p>The next step is then to build the service instances and register the service instances onto a server which will be demonstrated below.</p>
<p>You can definitely register services that are defined with <code>#[export_impl]</code> and <code>#[export_trait]</code> on the same server. However, for simplicity and consistency with the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html">service definition chapter</a>, in the discussions below, we are going to have separate examples. If you need an example where services defined with <code>#[export_impl]</code> and <code>#[export_trait]</code> are all registered on the same server, please refer to <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-server">this</a>.</p>
<h2 id="example-with-export_impl"><a class="header" href="#example-with-export_impl">Example with <code>#[export_impl]</code></a></h2>
<p>Let's just remind ourselves that in this example the service definition and implementation are located in the same file/project, and the file structure is as follows</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Using the service we have defined and implemented in the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_impl">previous chapter</a>, we are going instantiate those services and register those instances in <code>src/bin/server.rs</code>.</p>
<pre><code class="language-rust noplaypen">// src/bin/server.rs
use tokio::net::TcpListener;
use std::sync::Arc;
use toy_rpc::Server;

// Suppose the name of this crate is &quot;example&quot;
// Let's import the two services 
use example::{Foo, Bar}; 

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let foo = Arc::new(Foo { }); // instance of &quot;Foo&quot; service
    let bar = Arc::new(Bar { }); // instance of &quot;Bar&quot; service

    // Register the services onto a server
    let server = Server::builder()
        .register(foo) // register service instance with default name &quot;Foo&quot;
        .register(bar) // register service instance with default name &quot;Bar&quot;
        .build(); // build the server

    // Open a TcpListener for incoming connections
    let listener = TcpListener::bind(addr).await.unwrap();

    // Start our server and accept incoming connections and requests
    server.accept(listener).await.unwrap();
}
</code></pre>
<h2 id="example-with-export_trait-and-export_trait_impl"><a class="header" href="#example-with-export_trait-and-export_trait_impl">Example with <code>#[export_trait]</code> and <code>#[export_trait_impl]</code></a></h2>
<p>Now we are back with the example with <code>#[export_trait]</code> and <code>#[export_trait_impl]</code>, let's just remind ourselves that we have three separate crates where the service is defined in <code>&quot;example-service&quot;</code> and will be implemented in <code>&quot;example-server&quot;</code> as shown below.</p>
<p>We will continue to use the <code>tokio</code> runtime so that we don't need to change our <code>Cargo.toml</code> file, but because we will be implementing the service below, we will need to add <code>async-trait</code> and our service definition crate into our dependencies.</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;] }

# our service definition 
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<p>Now, let's implement the service and start the server</p>
<pre><code class="language-rust noplaypen">// src/main.rs

use tokio::net::TcpListener;
use std::sync::Arc;
use async_trait::async_trait;
use toy_rpc::Server;
use toy_rpc::macros::export_trait_impl;

// Import our service definition
// Make sure you import everything to include the auto-generated helper 
// traits that allow convenient service registration
use example_service::*;

struct Abacus { }

#[async_trait]
#[export_trait_impl] // The default service name will be &quot;Arith&quot;
impl Arith for Abacus {
    // Please note that you do NOT need to mark methods with
    // `#[export_method]` another time

    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }

    fn say_hi(&amp;self) {
        println!(&quot;hi&quot;);
    }
}

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let arith = Arc::new(Abacus{}); // create an instance of the `Arith` service
    let listener = TcpListener::bind(addr).await.unwrap();
    let server = Server::builder()
        .register(arith) // register service with default name &quot;Arith&quot;
        .build();

    println!(&quot;Starting server at {}&quot;, &amp;addr);
    server.accept(listener).await.unwrap()
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server-with-async-std-runtime"><a class="header" href="#server-with-async-std-runtime">Server with <code>async-std</code> runtime</a></h1>
<p>The overall usage with <code>async-std</code> runtime should look (almost) the same as the examples before. The only difference would be </p>
<ol>
<li>add <code>async_std</code> to your dependecies</li>
<li>enable feature <code>&quot;async_std_runtime&quot;</code> as opposed to <code>&quot;tokio_runtime&quot;</code></li>
<li>use <code>async_std::net::TcpListener</code> instead of <code>tokio::net::TcpListener</code></li>
</ol>
<p>If we were to run the server with <code>async-std</code> runtime, our previous <a href="https://minghuaw.github.io/toy-rpc/04_server.html#example-with-export_trait-and-export_trait_impl"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code> example</a> would then look like the code below.</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
async-std = { version = &quot;1.9.0&quot;, features = [&quot;attributes&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;async_std_runtime&quot;, &quot;server&quot;] }

# our service definition 
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<pre><code class="language-rust noplaypen">// src/main.rs

use async_std::net::TcpListener;
use std::sync::Arc;
use async_trait::async_trait;
use toy_rpc::Server;
use toy_rpc::macros::export_trait_impl;

// Import our service definition
// Make sure you import everything to include the auto-generated helper 
// traits that allow convenient service registration
use example_service::*;

struct Abacus { }

#[async_trait]
#[export_trait_impl] // The default service name will be &quot;Arith&quot;
impl Arith for Abacus {
    // Please note that you do NOT need to mark methods with
    // `#[export_method]` another time

    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }

    fn say_hi(&amp;self) {
        println!(&quot;hi&quot;);
    }
}

#[async_std::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let arith = Arc::new(Abacus{}); // create an instance of the `Arith` service
    let listener = TcpListener::bind(addr).await.unwrap();
    let server = Server::builder()
        .register(arith) // register service with default name &quot;Arith&quot;
        .build();

    println!(&quot;Starting server at {}&quot;, &amp;addr);
    server.accept(listener).await.unwrap()
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server-with-tokio-runtime"><a class="header" href="#server-with-tokio-runtime">Server with <code>tokio</code> runtime</a></h1>
<p>This is just going to be an identical copy of the previous <a href="https://minghuaw.github.io/toy-rpc/04_server.html#example-with-export_trait-and-export_trait_impl"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code> example</a>.</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;] }

# our service definition 
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<pre><code class="language-rust noplaypen">// src/main.rs

use tokio::net::TcpListener;
use std::sync::Arc;
use async_trait::async_trait;
use toy_rpc::Server;
use toy_rpc::macros::export_trait_impl;

// Import our service definition
// Make sure you import everything to include the auto-generated helper 
// traits that allow convenient service registration
use example_service::*;

struct Abacus { }

#[async_trait]
#[export_trait_impl] // The default service name will be &quot;Arith&quot;
impl Arith for Abacus {
    // Please note that you do NOT need to mark methods with
    // `#[export_method]` another time

    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }

    fn say_hi(&amp;self) {
        println!(&quot;hi&quot;);
    }
}

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let arith = Arc::new(Abacus{}); // create an instance of the `Arith` service
    let listener = TcpListener::bind(addr).await.unwrap();
    let server = Server::builder()
        .register(arith) // register service with default name &quot;Arith&quot;
        .build();

    println!(&quot;Starting server at {}&quot;, &amp;addr);
    server.accept(listener).await.unwrap()
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="integrations-with-http-server"><a class="header" href="#integrations-with-http-server">Integrations with HTTP Server</a></h1>
<p>HTTP integration is accomplished with WebSocket, and (currently) integration with three common <code>rust</code> HTTP server are supported by enabling the corresponding feature flag.</p>
<ul>
<li><code>actix-web</code>: <code>&quot;http_actix_web&quot;</code></li>
<li><code>tide</code>: <code>&quot;http_tide&quot;</code></li>
<li><code>warp</code>: <code>&quot;http_warp&quot;</code></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-integration-with-actix-web"><a class="header" href="#http-integration-with-actix-web">HTTP integration with <code>actix-web</code></a></h1>
<p>The <code>&quot;http_actix_web&quot;</code> feature flag should be toggled on to enable HTTP integration with <code>actix-web</code>. Enabling <code>&quot;http_actix_web&quot;</code> feature flag will also enable the <code>&quot;tokio_runtime&quot;</code> feature flag. </p>
<p>A convenience method <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.handle_http"><code>Server::handle_http()</code></a> is available when <code>&quot;http_actix_web&quot;</code> is the only enabled http integration feature flag. If you have multiple http integration feature flags enabled, you can use the <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.scope_config"><code>Server::scope_config</code></a> method instead (please note that you should use <code>scope_config</code> without brackets).</p>
<p>We will demonstrate the usage with a new example.</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;3.3.2&quot;
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;http_actix_web&quot;, &quot;server&quot;] }
</code></pre>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::macros::export_impl;
use toy_rpc::Server;
use actix_web::{web, HttpServer, App};

pub struct Calculator { }

#[export_impl]
impl Calculator {
    #[export_method]
    async fn multiply(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 * args.1)
    }

    #[export_method]
    async fn divide(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 / args.1)
    }
}

#[actix_web::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let calculator = Arc::new(Calculator { });
    let server = Server::builder()
        .register(calculator)
        .build();

    let app_data = web::Data::new(server);

    HttpServer::new(
        move || {
            App::new()
                .service(
                    web::scope(&quot;/rpc/&quot;)
                        .app_data(app_data.clone())
                        .configure(Server::handle_http()) // equivalent to the line below
                        // .configure(Server::scope_config)
                )
        }
    )
    .bind(addr).unwrap()
    .run()
    .await;
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-integration-with-actix-web-1"><a class="header" href="#http-integration-with-actix-web-1">HTTP integration with <code>actix-web</code></a></h1>
<p>The <code>&quot;http_tide&quot;</code> feature flag should be toggled on to enable HTTP integration with <code>tide</code>. Enabling <code>&quot;http_tide&quot;</code> feature flag will also enable the <code>&quot;async_std_runtime&quot;</code> feature flag.</p>
<p>A convenience method <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.handle_http-1"><code>Server::handle_http(self)</code></a> is available when <code>&quot;http_tide&quot;</code> is the only http integration flag that is enabled. If multiple http integration feature flags are enabled, you can use <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.into_endpoint"><code>Server::into_endpoint(self)</code></a> method instead.</p>
<p>We will demonstrate the usage with a new example.</p>
<pre><code class="language-toml">[dependencies]
tide = &quot;0.16.0&quot;
async-std = { version = &quot;1&quot;, features = [ &quot;attributes&quot;, ] }  
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;http_tide&quot;, &quot;server&quot;] }
</code></pre>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::macros::export_impl;
use toy_rpc::Server;
use tide::prelude::*;

pub struct Calculator { }

#[export_impl]
impl Calculator {
    #[export_method]
    async fn multiply(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 * args.1)
    }

    #[export_method]
    async fn divide(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 / args.1)
    }
}

#[async_std::main]
async fn main() {
    // Get the RPC server ready
    let addr = &quot;127.0.0.1:23333&quot;;
    let calculator = Arc::new(Calculator { });
    let server = Server::builder()
        .register(calculator)
        .build();

    // Now we will work with `tide` HTTP server
    let mut app = tide::new();
    app.at(&quot;/rpc/&quot;).nest(server.handle_http());
    app.listen(addr).await.unwrap();
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-integration-with-actix-web-2"><a class="header" href="#http-integration-with-actix-web-2">HTTP integration with <code>actix-web</code></a></h1>
<p>The <code>&quot;http_warp&quot;</code> feature flag should be toggled on to enable HTTP integration with <code>warp</code> crate. Enabling <code>&quot;http_warp&quot;</code> feature flag will also enable the <code>&quot;tokio_runtime&quot;</code> featrue flag.</p>
<p>A convenience method <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.handle_http-2"><code>Server::handle_http(self)</code></a> is available when <code>&quot;http_warp&quot;</code> is the only enabled http integration feature flag. If you have multiple http integration flags enabled, you can use the <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.into_boxed_filter"><code>Server::into_boxed_filter(self)</code></a> method instead.</p>
<p>We will demonstrate the usage with a new example.</p>
<pre><code class="language-toml">[dependencies]
warp = &quot;0.3.0&quot;
tokio = { version = &quot;1.4.0&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;http_warp&quot;, &quot;server&quot;] }
</code></pre>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::macros::export_impl;
use toy_rpc::Server;

pub struct Calculator { }

#[export_impl]
impl Calculator {
    #[export_method]
    async fn multiply(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 * args.1)
    }

    #[export_method]
    async fn divide(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 / args.1)
    }
}

#[tokio::main]
async fn main() {
    let calculator = Arc::new(Calculator { });
    let server = Server::builder()
        .register(calculator)
        .build();

    // Serve RPC at &quot;ws://127.0.0.1/rpc/&quot; 
    // (there is a &quot;_rpc_&quot; appended to the end of the path but the client takes care of that) 
    let routes = warp::path(&quot;rpc&quot;)
        .and(server.handle_http());
    warp::serve(routes).run(([127, 0, 0, 1], 23333)).await;
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<p>The client side usage should feel fairly close to that of the golang's <code>net/rpc</code> package as well except some changes that makes the client API more rusty and async. </p>
<p>To connect a client to a &quot;raw&quot; TCP server, you should use the <code>dial</code> function; to connect to a HTTP server, you should then use the <code>dial_http</code> function. Once you have a connected client,
you can then use the <code>call_blocking</code> and <code>call</code> methods to access the RPC functions on the server. The <code>#[export_impl]</code> and <code>#[export_trait]</code> attribute macros also generates client stub functions that allows the client to conveniently access the RPC functions without worrying about typing the wrong service or method name. </p>
<h1 id="connecting-to-tcp-server--http-server"><a class="header" href="#connecting-to-tcp-server--http-server">Connecting to TCP server / HTTP server</a></h1>
<p>For the examples below, we will assume running with the <code>tokio</code> runtime.</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;client&quot;] }
</code></pre>
<p>The example below shows how to connect to a TCP server</p>
<pre><code class="language-rust noplaypen">use toy_rpc::Client;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to server&quot;);
}
</code></pre>
<p>Connecting to the HTTP server looks very similar with some minor changes. The example below assumes that we are trying to connect to one of the <a href="https://minghuaw.github.io/toy-rpc/05_integration.html">HTTP servers</a> (all three HTTP integration examples have the RPC server serving at <code>&quot;ws://127.0.0.1:23333/rpc/&quot;</code>). Please note that there is a &quot;<em>rpc</em>&quot; appended to the end of the path by the server integration methods, but this is automatically handled by the <code>Client::dial_http</code> method so you don't need to worry about that. </p>
<pre><code class="language-rust noplaypen">use toy_rpc::Client;

#[tokio::main]
async fn main() {
    let client = Client::dial_http(&quot;ws://127.0.0.1:23333/rpc/&quot;).await
        .expect(&quot;Failed to connect to server&quot;);
}
</code></pre>
<h1 id="accessing-rpc-services"><a class="header" href="#accessing-rpc-services">Accessing RPC services</a></h1>
<h2 id="call_blocking-and-call"><a class="header" href="#call_blocking-and-call"><code>call_blocking(...)</code> and <code>call(...)</code></a></h2>
<p>There are two methods available for accessing the RPC services and methods. The <code>call_blocking</code> method blocks the execution until the response is received, and the <code>call</code> method is the asynchronous version where the execution will yield to other tasks scheduled by the runtime while waiting for the response. Cancellation is also supported on the <code>call</code> method, which is discussed with more details in the <a href="https://minghuaw.github.io/toy-rpc/06a_cancellation.html">next chapter</a>.</p>
<p>(Support of timeout is still work-in-progress. The book will be updated once the feature is implemented.)</p>
<h2 id="generated-client-stub-functions"><a class="header" href="#generated-client-stub-functions">Generated client stub functions</a></h2>
<p>The generated client stub functions internally uses the <code>call(...)</code> method and are thus async. The client stub functions consist of two steps. The first step is to access your service, and the second step is to access the method defined in that particular service. The method in the first step is always the name of the service but in snake case. For example, if you have a service <code>struct FooBar { }</code>, then the client method you use to access the service will be <code>foo_bar()</code>. The client method you use to access the method is identical to the method definition in the RPC service. For example, if an RPC method is defined as <code>fn add(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt;;</code>, then the client method you use would be <code>client.bar().add((3i32, 4i32)).await;</code></p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>We will continue the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_impl"><code>#[export_impl]</code> example</a> and the [<code>#[export_trait]</code> and <code>#[export_trait_impl]</code>] example to demonstrate how to access RPC service on the server. The methods you will use to access the RPC service are the same for a TCP connection and a HTTP connection, and for simplicity, all the examples below will assume a TCP connection. For more examples on use with HTTP connections, please checkout the <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples">GitHub examples</a>.</p>
<h3 id="export_impl-1"><a class="header" href="#export_impl-1"><code>#[export_impl]</code></a></h3>
<p>Let's just remind ourselves that in this example the service definition and implementation are located in the same file/project, and the file structure is as follows</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Since the service is defined and implemented in <code>src/lib.rs</code> from the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_impl">previous chapter</a>, we are going to include everything in the <code>src/lib.rs</code> file to allow us use the generated client stub functions in our <code>src/bin/client.rs</code>.</p>
<pre><code class="language-rust noplaypen noplaypen">use toy_rpc::Client;
use toy_rpc::Error;

// include everything from the lib.rs file
// assuming the name of the crate is &quot;example&quot;
use example::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to the server&quot;);

    // Access the remote `exported_method` method of `Foo` service in a blocking manner
    let result: Result&lt;String, Error&gt; = client.call_blocking(&quot;Foo.exported_method&quot;, ());
    println!(&quot;{:?}&quot;, result);

    // Access the remote `add` method of `Bar` service in an asynchronous manner
    let result: Result&lt;i32, Error&gt; = client.call(&quot;Bar.add&quot;, (3i32, 4i32)).await;
    println!(&quot;{:?}&quot;, result);

    // You can also use the generated client stub functions
    // Access the remote `exported_method` method of `Foo` service 
    // using the generated client stub functions
    let result = client
        .foo() // access `Foo` service
        .exported_method(()) // access `exported_method` of the `Foo` service
        .await;
    println!(&quot;{:?}&quot;, result);

    // Access the remote `add` method of `Bar` service 
    // using the generated client stub functions
    let result = client
        .bar()
        .add((3, 4))
        .await;
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<h3 id="export_trait-and-export_trait_impl-1"><a class="header" href="#export_trait-and-export_trait_impl-1"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code></a></h3>
<p>Again, let's just remind ourselves that the service in this example is defined in a separate crate <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_trait-and-export_trait_impl"><code>example-service</code></a> and the service is implemented and served by <a href="https://minghuaw.github.io/toy-rpc/04_server.html#example-with-export_trait-and-export_trait_impl"><code>example-server</code></a> crate. What we will be doing below is to demonstrate the client, which, not surprisingly, look pretty much the same as the example above.</p>
<p>Because the service definition resides in a separate crate, we will need to import that crate as well.</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;client&quot;] }

# import our service definition, assuming we have this definition at &quot;../example-service&quot;
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<pre><code class="language-rust noplaypen">use toy_rpc::{Client, Error};

// import everything to use the generated client stub functions
use example_service::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to the server&quot;);
    
    // Access the remote method `add` of service `Arith` in a blocking manner
    let result: Result&lt;i32, Error&gt; = client.call_blocking(&quot;Arith.add&quot;, (3i32, 4i32));
    println!(&quot;{:?}&quot;, result);

    // Access the remote method `subtract` of service `Arith` in an asynchronous manner
    let result: Result&lt;i32, Error&gt; = client.call(&quot;Arith.subtract&quot;, (9i32, 6i32)).await;
    println!(&quot;{:?}&quot;, result);

    // Let's use the generated client stub functions
    let result = client
        .arith() // access `Arith` service
        .add((3i32, 4i32)) // access `add` method
        .await;
    println!(&quot;{:?}&quot;, result);

    let result = client
        .arith() // access `Arith` service
        .subtract((9i32, 6i32)) // access `subtract` method
        .await;
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cancellation-of-rpc-call"><a class="header" href="#cancellation-of-rpc-call">Cancellation of RPC call</a></h1>
<p>Cancellation is supported starting from version 0.7.0-alpha.2. The client method <code>call(...)</code> returns a type <code>Call</code>, which can be either <code>.await</code>ed for the response or <code>cancel()</code>ed to stop the execution. When an RPC request is started with the method <code>call(...)</code>, the request is sent by a background task whether or not the <code>Call</code> is <code>.await</code>ed. Upon <code>cancel()</code>, the client will send a cancellation request to the server; however, it should be noted that if the client is dropped immediately after calling <code>cancel()</code>, the server may not be able to receive the cancellation request before the connection is dropped by the client.</p>
<p>Below is a simple example showing cancellation on the <code>tokio</code> runtime.In this example, we are going to define a new service with a method that simply runs in loop and sleep for a certain period of time.</p>
<p>File structure:</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Add dependencies:</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;time&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;, &quot;client&quot;] }
</code></pre>
<p>Service definition and implementation placed in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use toy_rpc::macros::export_impl;
use tokio::time;

struct Example { }

#[export_impl]
impl Example {
    #[export_method]
    async fn finite_loop(&amp;self, args: ()) -&gt; Result&lt;(), String&gt; {
        for counter in 0..500 {
            time::sleep(Duration::from_millis(500)).await;
        }
    }

    #[export_method]
    async fn echo(&amp;self, args: String) -&gt; Result&lt;String, String&gt; {
        Ok(args)
    }
}
</code></pre>
<p>Serve the RPC service with <code>src/bin/server.rs</code></p>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::Server;
use tokio::net::TcpListener;

// assume the name of the crate is &quot;example&quot;
// import service definition and implementation
use example::Example;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let ex = Arc::new(Example { });
    let server = Server::builder()
        .register(ex)
        .build()

    let listener = TcpListener::bind(addr).await.unwrap();
    server.accept(listener).await.unwrap();
}
</code></pre>
<p>On the client side, let's call the <code>finite_loop</code> RPC function and wait for two seconds and cancel it.</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use tokio::time;
use toy_rpc::client::{Client, Call};

// assume the name of the crate is &quot;example&quot;
// import service definitions and generated client stub functions
use example::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to server&quot;);

    let call: Call&lt;()&gt; = client
        .example() // access `Example` service
        .finite_loop(()); // access `finite_loop` method

    // wait for 2 seconds and cancel
    time::sleep(Duration::from_secs(2)).await;
    call.cancel();
    // You can still .await on a canceled Call, but this will return an error
    let reply = call.await;
    println!(&quot;{:?}&quot;, reply); // Err(Error::Canceled(Some(id)))

    // the `Call` type can be `.await`ed to wait for the response
    let call = client
        .example() // access `Example` service
        .echo(&quot;hello world&quot;.to_string()); // access `echo` method
    let result = call.await;
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="set-timeout-for-an-rpc-call"><a class="header" href="#set-timeout-for-an-rpc-call">Set timeout for an RPC call</a></h1>
<p>The client can set the timeout for the next RPC request using the <code>timeout(duration: Duration)</code> method, which can be chained with the <code>call</code> method. Please note that the timeout is <strong>ONLY</strong> set for the immediate next RPC call, and all RPC calls do not have timeout if not explicitly set using the <code>timeout</code> method.</p>
<p>We will re-use the example service definition in the <a href="https://minghuaw.github.io/toy-rpc/06a_cancellation.html">cancellation chapter</a>. For you convenience, the service definition and server code are copied below.</p>
<p>File structure:</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Add dependencies:</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;time&quot;] }
toy-rpc = { version = &quot;0.7.0-alpha.2&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;, &quot;client&quot;] }
</code></pre>
<p>Service definition and implementation placed in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use toy_rpc::macros::export_impl;
use tokio::time;

struct Example { }

#[export_impl]
impl Example {
    #[export_method]
    async fn finite_loop(&amp;self, args: ()) -&gt; Result&lt;(), String&gt; {
        for counter in 0..500 {
            time::sleep(Duration::from_millis(500)).await;
        }
    }

    #[export_method]
    async fn echo(&amp;self, args: String) -&gt; Result&lt;String, String&gt; {
        Ok(args)
    }
}
</code></pre>
<p>Serve the RPC service with <code>src/bin/server.rs</code>.</p>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::Server;
use tokio::net::TcpListener;

// assume the name of the crate is &quot;example&quot;
// import service definition and implementation
use example::Example;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let ex = Arc::new(Example { });
    let server = Server::builder()
        .register(ex)
        .build()

    let listener = TcpListener::bind(addr).await.unwrap();
    server.accept(listener).await.unwrap();
}
</code></pre>
<p>On the client side, let's call the <code>finite_loop</code> RPC function with a timeout of three seconds.</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use tokio::time;
use toy_rpc::client::{Client, Call};

// assume the name of the crate is &quot;example&quot;
// import service definitions and generated client stub functions
use example::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to server&quot;);

    let call: Call&lt;()&gt; = client
        .timeout(Duration::from_secs(3))
        .example() // access `Example` service
        .finite_loop(()); // access `finite_loop` method
    let result = call.await; // This should give you `Err(Error::Timeout)`
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tls-support"><a class="header" href="#tls-support">TLS Support</a></h1>
<p>Support for TLS is implemented with <code>rustls</code> and its <code>async</code> derivatives <code>async-rustls</code> and <code>tokio-rustls</code>. </p>
<p>An example using a self-signed certificate can be found in the <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_tls">GitHub repo</a>.</p>
<p>More detailed documentations are underway.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>There are a few examples available on the <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples">GitHub repo</a>. Here are some descriptions of those examples.</p>
<ul>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/async_std_tcp">&quot;Raw&quot; TCP server and client with <code>async-std</code> runtime</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_tcp">&quot;Raw&quot; TCP server and client with <code>tokio</code> runtime</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/cancel_and_timeout">Cancellation and timeout of RPC call</a></li>
<li>Service definition, server implementation, and client implementation in three separate crates
<ul>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-service">service</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-server">server</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-client">client</a></li>
</ul>
</li>
<li>HTTP integrations
<ul>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/actix_v3_integration"><code>actix-web</code></a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tide_integration"><code>tide</code></a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/warp_integration"><code>warp</code></a></li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="change-log"><a class="header" href="#change-log">Change Log</a></h1>
<h2 id="070"><a class="header" href="#070">0.7.0</a></h2>
<p><strong>Breaking Changes</strong></p>
<ul>
<li>The blocking RPC call on the client side is renamed to <code>call_blocking</code></li>
<li>The asynchronous RPC call on the client side is renamed to <code>call</code></li>
<li>The <code>call</code> method returns a <code>Call&lt;Res&gt;</code> type where <code>Res</code> represents the <code>Ok</code> type of 
result. The request is sent by a background task and thus the new <code>call</code> method is 
similar to the old <code>spawn_task</code> in terms of usage.</li>
</ul>
<p><strong>New Features</strong></p>
<ul>
<li>Cancellation. The <code>Call&lt;Res&gt;</code> type returned by the <code>call</code> method can be canceled by 
using the <code>cancel()</code> method.</li>
<li>Timeout. A timeout can be set for the next request by calling <code>client.timeout(duration)</code>. 
only one request after setting the timeout is going to run with a timeout. If you want to set timeout
for multiple requests, you need to set the timeout for each of them.</li>
</ul>
<h2 id="061"><a class="header" href="#061">0.6.1</a></h2>
<ul>
<li>Multiple objects of the same types can be registered on the same server again, but you will need to
use the <code>ServerBuilder::register_with_name</code> method as opposed to the regular <code>ServerBuilder::register</code>.
More details can be found in <code>ServerBuilder::register_with_name</code>'s documentation.</li>
</ul>
<h2 id="060"><a class="header" href="#060">0.6.0</a></h2>
<p><strong>Breaking Changes</strong></p>
<ul>
<li>In short, this update makes the crate resemble closer to the usage of <code>go</code>'s <code>net/rpc</code> package</li>
<li>Service registration is simplified to <code>Server::builder().register(foo_service).build()</code>. The examples will be
updated accordingly. Thus
<ul>
<li><code>service!()</code> macro will be deprecated</li>
<li><code>register</code> function now takes only one argument, which is the instance of the service</li>
<li>on the client side, the service name will just be the name of the struct. for example,
to call a RPC method on <code>struct Foo { }</code> service, the client simply uses
<code>.async_call(&quot;Foo.&lt;method&gt;&quot;).await</code> where <code>&lt;method&gt;</code> should be replaced with the RPC method</li>
<li>you can still register multiple services on the same server. However, only one object of the same type
can be registered on the same server. Multiple servers are needed to have multiple objects of the same type.</li>
</ul>
</li>
<li>Re-defined the custom <code>Error</code> type</li>
</ul>
<p>Non-breaking changes</p>
<ul>
<li>Fixed bug where client does not interpret error message correctly</li>
<li>Fixed bug with <code>accept_websocket</code> crashes with incorrect protocol</li>
</ul>
<h2 id="054"><a class="header" href="#054">0.5.4</a></h2>
<ul>
<li>Handlers are now stored as a <code>fn</code> pointer as opposed to a trait object.</li>
</ul>
<h2 id="053"><a class="header" href="#053">0.5.3</a></h2>
<ul>
<li>The <code>#[export_impl]</code> macro now generates client stub functions by generating a new trait for <code>toy_rpc::Client</code>.</li>
</ul>
<h2 id="050"><a class="header" href="#050">0.5.0</a></h2>
<p><strong>Breaking changes</strong></p>
<ul>
<li>HTTP integration is now accomplished using WebSocket with <code>async_tungstenite</code>, and thus HTTP connections
of versions &lt;0.5.0 are not compatible with versions &gt;=0.5.0.</li>
<li>The custom binary transport protocol now includes a magic byte at the beginning, making
versions &lt;0.5.0 <strong>NOT</strong> compatible with versions &gt;= 0.5.0;</li>
<li><code>toy_rpc::error::Error</code> changed from struct-like variants to simple enum variants</li>
<li>Changes to feature flags
<ul>
<li>&quot;logging&quot; feature flag is removed</li>
<li>&quot;surf&quot; feature flag is removed</li>
<li>&quot;tide&quot; is changed to &quot;http_tide&quot;</li>
<li>&quot;actix-web&quot; is changed to &quot;http_actix_web&quot;</li>
<li>added &quot;http_warp&quot; feature flag</li>
<li>added &quot;async_std_runtime&quot;</li>
<li>added &quot;tokio_runtime&quot;</li>
</ul>
</li>
</ul>
<p>Non-breaking changes</p>
<ul>
<li>Removed <code>Stream</code> and <code>Sink</code> impl from the custom binary transport protocol <code>Frame</code></li>
</ul>
<h2 id="045"><a class="header" href="#045">0.4.5</a></h2>
<ul>
<li>Added <code>Sink</code> implementation for the custom binary transport protocol <code>Frame</code></li>
</ul>
<h2 id="044"><a class="header" href="#044">0.4.4</a></h2>
<ul>
<li>Modified traits <code>CodecRead</code>, <code>CodecWrite</code>, <code>ServerCodec</code>, <code>ClientCodec</code> to no longer
return number of bytes written</li>
<li>The number of bytes written for header and body will be logged separately</li>
</ul>
<h2 id="043"><a class="header" href="#043">0.4.3</a></h2>
<ul>
<li>Removed previously unused NoneError</li>
<li>Unified <code>call</code>, <code>async_call</code> and <code>spawn_task</code> for socket client
and HTTP client. The <code>call_http</code>, <code>async_call_http</code>, and <code>spawn_task_http</code>
methods are kept for compatibility.</li>
</ul>
<h2 id="042"><a class="header" href="#042">0.4.2</a></h2>
<ul>
<li>Temporary fix of <code>spawn_task()</code> and <code>spawn_task_http()</code> with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> until
lifetime with async task is figured out. As a result, <code>Client</code> no longer needs to be declared <code>mut</code>.</li>
</ul>
<h2 id="041"><a class="header" href="#041">0.4.1</a></h2>
<ul>
<li>Updated documentation</li>
</ul>
<h2 id="040"><a class="header" href="#040">0.4.0</a></h2>
<ul>
<li>Added <code>actix-web</code> feature flag to support integration with <code>actix-web</code></li>
</ul>
<h2 id="031"><a class="header" href="#031">0.3.1</a></h2>
<ul>
<li>Added <code>serde_rmp</code> features flag</li>
<li>Updated and corrected examples in the documentation</li>
</ul>
<h2 id="030"><a class="header" href="#030">0.3.0</a></h2>
<ul>
<li>Added <code>serde_cbor</code> feature flag</li>
<li>Changed <code>bincode</code> feature flag to <code>serde_bincode</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
