<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>toy-rpc Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="03_define_service.html"><strong aria-hidden="true">3.</strong> Define Service</a></li><li class="chapter-item expanded "><a href="04_server.html"><strong aria-hidden="true">4.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04a_async_std.html"><strong aria-hidden="true">4.1.</strong> async-std</a></li><li class="chapter-item expanded "><a href="04b_tokio.html"><strong aria-hidden="true">4.2.</strong> tokio</a></li></ol></li><li class="chapter-item expanded "><a href="05_integration.html"><strong aria-hidden="true">5.</strong> Integration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05a_actix_web.html"><strong aria-hidden="true">5.1.</strong> actix-web</a></li><li class="chapter-item expanded "><a href="05b_tide.html"><strong aria-hidden="true">5.2.</strong> tide</a></li><li class="chapter-item expanded "><a href="05c_warp.html"><strong aria-hidden="true">5.3.</strong> warp</a></li></ol></li><li class="chapter-item expanded "><a href="06_client.html"><strong aria-hidden="true">6.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06a_cancellation.html"><strong aria-hidden="true">6.1.</strong> Cancellation</a></li><li class="chapter-item expanded "><a href="06b_timeout.html"><strong aria-hidden="true">6.2.</strong> Timeout</a></li></ol></li><li class="chapter-item expanded "><a href="07_tls.html"><strong aria-hidden="true">7.</strong> TLS Support</a></li><li class="chapter-item expanded "><a href="08_pubsub.html"><strong aria-hidden="true">8.</strong> PubSub</a></li><li class="chapter-item expanded "><a href="09_examples.html"><strong aria-hidden="true">9.</strong> Examples</a></li><li class="chapter-item expanded "><a href="10_preview.html"><strong aria-hidden="true">10.</strong> Version 0.9 Preview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10a_alpha.1.html"><strong aria-hidden="true">10.1.</strong> 0.9.0-alpha.1</a></li><li class="chapter-item expanded "><a href="10b_alpha.2.html"><strong aria-hidden="true">10.2.</strong> 0.9.0-alpha.2</a></li></ol></li><li class="chapter-item expanded "><a href="change_log.html"><strong aria-hidden="true">11.</strong> Change Logs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">toy-rpc Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div align="center">
<!-- Crates version -->
<a href="https://crates.io/crates/toy-rpc">
<img src="https://img.shields.io/crates/v/toy-rpc.svg?style=flat" alt="Crates.io version" />
</a>
<!-- docs.rs docs -->
<a href="https://docs.rs/toy-rpc">
<img src="https://img.shields.io/badge/docs-latest-blue.svg?style=flat" alt="docs.rs docs" />
</a>
<!-- Downloads -->
<a href="https://crates.io/crates/toy-rpc">
<img src="https://img.shields.io/crates/d/toy-rpc.svg?style=flat" alt="Download" />
</a>
<a href="https://github.com/rust-secure-code/safety-dance/">
<img src="https://img.shields.io/badge/unsafe-forbidden-success.svg?style=flat" alt="Unsafe Rust forbidden" />
</a>
</div>
<p><code>toy-rpc</code> aims to be an easy-to-use <code>async</code> RPC tool that is inspired by golang's <code>net/rpc</code>'s API. 
It supports both <code>async_std</code> and <code>tokio</code> runtimes over either TCP or TLS. Integration with common HTTP server frameworks such as <code>actix_web</code>, <code>warp</code> and <code>tide</code>
are provided.</p>
<p>The overall usage and API should feel similar to that of the golang's <code>net/rpc</code> package. Some of the names are changed 
to make them sound more &quot;rusty&quot;. Because rust does not come with runtime reflection, attribute macros <code>#[export_impl]</code>
and <code>#[export_trait]</code> / <code>#[export_trait_impl]</code>, and attribute <code>#[export_method]</code> are used to mark functions &quot;exported&quot; in golang's 
<code>net/rpc</code> perspective.</p>
<p>Minimum supported Rust version: 1.53 or later</p>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>While there are grpc implementations like <code>grpc-rs</code> and <code>tonic</code> as well as schema-free crates like <code>tarpc</code>, I didn't find 
a crate that offers the same level of ease-of-use as that of the golang's <code>net/rpc</code> package. Other than the ease-of-use,
not many async RPC crates work with both <code>async_std</code> and <code>tokio</code> runtime and could be difficult to integrate with the common
async HTTP crates (<code>actix_web</code>, <code>warp</code>, and <code>tide</code>). Thus I started working on this crate to bring something that is 
easy-to-use and supports both <code>async_std</code> and <code>tokio</code> runtimes.</p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature flags</a></h2>
<p>Most of the feature flags can be put into three categories.</p>
<p>Choice of runtime and HTTP framework integration</p>
<ul>
<li><code>async_std_runtime</code>: supports usage with <code>async-std</code></li>
<li><code>tokio_runtime</code>: supports usage with <code>tokio</code></li>
<li><code>http_tide</code>: enables <code>tide</code> integration on the server side. This also enables <code>async_std_runtime</code> and <code>ws_async_std</code></li>
<li><code>http_actix_web</code>: enables <code>actix-web</code> integration on the server side. This also enables <code>tokio_runtime</code> and <code>ws_tokio</code></li>
<li><code>http_warp</code>: enables integration with <code>warp</code> on the server side. This also enables <code>tokio_runtime</code> and <code>ws_tokio</code></li>
<li><code>http_axum</code>: enables integration with <code>axum</code> on the server side. This also enables <code>tokio_runtime</code> and <code>ws_tokio</code></li>
</ul>
<p>Choice of RPC server or client (both can be enabled at the same time)</p>
<ul>
<li><code>server</code>: enables RPC server</li>
<li><code>client</code>: enables RPC client. Please note that <code>ws</code> must also be enabled for client to use <code>dial_http(addr)</code> or <code>dial_websocket(addr)</code>.</li>
</ul>
<p>Choice of serialization/deserialzation (only one should be enabled at a time)</p>
<ul>
<li><code>serde_bincode</code>: (default) the default codec will use <code>bincode</code>
for serialization/deserialization</li>
<li><code>serde_json</code>: the default codec will use <code>serde_json</code>
for <code>json</code> serialization/deserialization</li>
<li><code>serde_cbor</code>: the default codec will use <code>serde_cbor</code>
for serialization/deserialization</li>
<li><code>serde_rmp</code>: the default codec will use <code>rmp-serde</code>
for serialization/deserialization</li>
</ul>
<p>WebSocket support (HTTP integration is implemented using WebSocket)</p>
<ul>
<li><code>ws_tokio</code>: enables WebSocket and HTTP integrations with <code>tokio</code>. 
This must be enabled for client to use <code>dial_http(addr)</code> or <code>dial_websocket(addr)</code> with <code>tokio_runtime</code>.</li>
<li><code>ws_async_std</code>: enables WebSocket and HTTP integrations with <code>async-std</code>. 
This must be enabled for client to use <code>dial_http(addr)</code> or <code>dial_websocket(addr)</code> with <code>async_std_runtime</code>.</li>
</ul>
<p>TLS support</p>
<ul>
<li><code>tls</code>: enables TLS support</li>
</ul>
<p>Convenience conversion to <code>anyhow::Error</code></p>
<ul>
<li><code>anyhow</code>: enables using <code>anyhow::Error</code> in RPC methods</li>
</ul>
<p>Other trivial feature flags are listed below, and they are likely of no actual usage for you.</p>
<ul>
<li><code>docs</code></li>
<li><code>std</code>: <code>serde/std</code>. There is no actual usage right now.</li>
</ul>
<p>By default, only <code>serde_bincode</code> feature is enabled. 
You must enable at least one runtime feature flag and the <code>server</code> and/or <code>client</code> to have something usable.</p>
<h2 id="default-features"><a class="header" href="#default-features">Default features</a></h2>
<pre><code class="language-toml">default = [
    &quot;serde_bincode&quot;,
]
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>A simple quickstart with <code>tokio</code> runtime is shown below. More examples can be found in the <strong>Example</strong> chapter.</p>
<h2 id="initialize-new-project"><a class="header" href="#initialize-new-project">Initialize new project</a></h2>
<p><code>cargo new --lib toy_rpc_quickstart</code></p>
<h2 id="add-dependencies"><a class="header" href="#add-dependencies">Add dependencies</a></h2>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;, &quot;client&quot;] }
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h2>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>In the <code>Cargo.toml</code>, you may need to specify the binaries with </p>
<pre><code class="language-toml">[[bin]]
name = &quot;server&quot;
path = &quot;src/bin/server.rs&quot;

[[bin]]
name = &quot;client&quot;
path = &quot;src/bin/client.rs&quot; 
</code></pre>
<h2 id="define-rpc-service"><a class="header" href="#define-rpc-service">Define RPC service</a></h2>
<p>In <code>src/lib.rs</code></p>
<pre><code class="language-rust noplaypen">// src/lib.rs

pub mod rpc {
    use toy_rpc::macros::export_impl;
    pub struct Echo { }
    
    #[export_impl]
    impl Echo {
        #[export_method]
        pub async fn echo_i32(&amp;self, arg: i32) -&gt; Result&lt;i32, String&gt; {
            Ok(arg)
        }
    }
}
</code></pre>
<h2 id="rpc-server"><a class="header" href="#rpc-server">RPC server</a></h2>
<p>In <code>src/bin/server.rs</code></p>
<pre><code class="language-rust noplaypen">// src/bin/server.rs

use tokio::{task, net::TcpListener};
use std::sync::Arc;
use toy_rpc::Server;

use toy_rpc_quickstart::rpc::Echo;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    
    // Creates an instance of the `Echo` service
    let echo_service = Arc::new(
        Echo { }
    );

    let server = Server::builder()
        .register(echo_service) // register service
        .build();
    let listener = TcpListener::bind(addr).await.unwrap();

    // Run the server in a separate task
    let handle = task::spawn(async move {
        println!(&quot;Starting server at {}&quot;, &amp;addr);
        server.accept(listener).await.unwrap();
    });
    handle.await.expect(&quot;Error running the RPC server&quot;);
}
</code></pre>
<h2 id="rpc-client"><a class="header" href="#rpc-client">RPC client</a></h2>
<p>In <code>src/bin/client.rs</code></p>
<pre><code class="language-rust noplaypen">use toy_rpc::Client;

// import everything including the client stub generated by the macro
use toy_rpc_quickstart::rpc::*;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let client = Client::dial(addr).await.unwrap();

    let result: i32 = client
        .echo() // calling service `Echo`
        .echo_i32(3i32) // calling RPC method `echo_i32`
        .await  
        .unwrap();
    println!(&quot;{:?}&quot;, result);

    // The above call is equivalent to
    let result: i32 = client
        .call(&quot;Echo.echo_i32&quot;, 3i32)
        .await
        .unwrap();
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="define-service"><a class="header" href="#define-service">Define Service</a></h1>
<p>There are two ways (but three attribute macros) to help you define the the RPC service.</p>
<ul>
<li>The attribute macro <code>#[export_impl]</code> can be used when the implementation and the service definition are 
located in the same file/project. The name of the <code>struct</code> will be used as the default service name with <code>#[export_impl]</code> in a case sensitive manner.</li>
<li>The attribute macros <code>#[export_trait]</code> and <code>#[export_trait_impl]</code> should be used when an abstract service definition (a <code>trait</code>) will be shared among different projects. The name of the <code>trait</code> will be used as the default service name with <code>#[export_trait]</code> in a case sensitive manner.</li>
</ul>
<p>Both <code>#[export_impl]</code> and <code>#[export_trait]</code> will generate the client stub traits/methods when the &quot;client&quot; feature flag is enabled and a runtime feature flag is enabled on <code>toy-rpc</code>.</p>
<p>Inside the <code>impl</code> block or <code>trait</code> definition block, you should then use the attribute 
<code>#[export_method]</code> to mark which method(s) should be &quot;exported&quot; as RPC method(s). 
The methods to export must meet the following criteria on the server side</p>
<ul>
<li>the method resides in an impl block marked with <code>#[export_impl]</code> or <code>#[export_trait]</code></li>
<li>the method is marked with <code>#[export_method]</code> attribute</li>
<li>the method takes one argument other than <code>&amp;self</code> and returns a <code>Result&lt;T, E&gt;</code>
<ul>
<li>the argument must implement trait <code>serde::Deserialize</code></li>
<li>the <code>Ok</code> type <code>T</code> of the result must implement trait <code>serde::Serialize</code></li>
<li>the <code>Err</code> type <code>E</code> of the result must implement trait <code>ToString</code></li>
</ul>
</li>
</ul>
<p>The method is essentially in the form</p>
<pre><code class="language-rust noplaypen">#[export_method]
async fn method_name(&amp;self, args: Req) -&gt; Result&lt;Res, ErrorMsg&gt;
where
    Req: serde::Deserialize,
    Res: serde::Serialize,
    ErrorMsg: ToString,
{
    // ...
}
</code></pre>
<h2 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h2>
<p>Use the following dependencies to work with the examples below</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
toy-rpc = &quot;0.7.5&quot;
</code></pre>
<h3 id="export_impl"><a class="header" href="#export_impl"><code>#[export_impl]</code></a></h3>
<p>When you have both the service definition and the implementation in the same file, you can use <code>#[export_impl]</code> on the <code>impl</code> block. This will also use the name of the <code>struct</code> as the default service name.</p>
<p>File structure </p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Suppose that <em>both</em> the service definitions and implementations are placed in <code>src/lib.rs</code>.</p>
<pre><code class="language-rust noplaypen">// src/lib.rs
use toy_rpc::macros::export_impl;

pub struct Foo { }

#[export_impl] // The default service name will be &quot;Foo&quot;
impl Foo {
    // use attribute `#[export_method]` to mark which method to &quot;export&quot;
    #[export_method]
    async fn exported_method(&amp;self, args: ()) -&gt; Result&lt;String, String&gt; {
        Ok(&quot;exported method&quot;.into())
    }

    async fn not_exported_method(&amp;self, args: ()) -&gt; Result&lt;String, String&gt; {
        Ok(&quot;not exported method&quot;.into())
    }
}
</code></pre>
<p>You may also define a separate trait in <code>src/lib.rs</code> which is implemented by some <code>struct</code> in the same file.</p>
<pre><code class="language-rust noplaypen">// continuing in src/lib.rs

use async_trait::async_trait;

#[async_trait]
pub trait Arith {
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;
}

pub struct Bar { }
// implement the Arith trait for `Bar { }`and then mark the implementation as &quot;exported&quot; for RPC

#[async_trait]
// Place `#[export_impl] ` after `#[async_trait]`
#[export_impl] // The default service name will be &quot;Bar&quot;
impl Arith for Bar {
    // Only mark `add(...)` as RPC method
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    // `subtract(...)` will not be accessible from RPC calls
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }
}
</code></pre>
<p>We will continue to use this example in the <a href="https://minghuaw.github.io/toy-rpc/04_server.html">Server</a> and <a href="https://minghuaw.github.io/toy-rpc/06_client.html">Client</a> chapters.</p>
<h3 id="export_trait-and-export_trait_impl"><a class="header" href="#export_trait-and-export_trait_impl"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code></a></h3>
<p>When you want the abstract service definition to be shared but without concreate implementations, you should use <code>#[export_trait]</code> on the trait definition and <code>#[export_trait_impl]</code> on the concrete trait implementation. Please note that the default service name hence will be the name of the <code>trait</code> <strong>NOT</strong> that of the <code>struct</code>.</p>
<p>Suppose we will have three separate crates</p>
<ul>
<li><code>&quot;example-service&quot;</code> as the service definition,</li>
<li><code>&quot;example-server&quot;</code> acting as the server,</li>
<li>and <code>&quot;example-client&quot;</code> acting as the client</li>
</ul>
<p>which can also be found in the GitHub examples (<a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-service">service</a>, <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-server">server</a>, <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-client">client</a>).</p>
<p>We are going to define the RPC service just as a trait in <code>&quot;example-service&quot;</code>.</p>
<pre><code class="language-rust noplaypen">// example-service/src/lib.rs
use async_trait::async_trait;
use toy_rpc::macros::export_trait;

#[async_trait]
#[export_trait] // The default service name will be &quot;Arith&quot;
pub trait Arith {
    // let's mark both `add(...)` and `subtract(...)` as RPC method
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;

    #[export_method]
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt;;

    // some method that we don't want to export
    fn say_hi(&amp;self);
}
</code></pre>
<p>We will continue to use this example in the <a href="https://minghuaw.github.io/toy-rpc/04_server.html">Server</a> and <a href="https://minghuaw.github.io/toy-rpc/06_client.html">Client</a> chapters.</p>
<p>If you want to the <code>Client</code> implements the RPC trait and don't care about cancelling the RPC call, the implementation can be conveniently generated with an argument <code>(impl_for_client)</code> in the attribute macro <code>#[export_trait]</code>. The usage will demonstrated below.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
#[export_trait(impl_for_client)] // This will generate `Arith` trait implementation for `toy_rpc::Client`
pub trait Arith {
    // let's mark both `add(...)` and `subtract(...)` as RPC method
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, anyhow::Error&gt;;

    #[export_method]
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, toy_rpc::Error&gt;;

    // All methods must be exported if trait implementation generation is enabled
    // fn say_hi(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will allow convenient client usage like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// client.rs

let reply = Arith::add(&amp;client, (3,4)).await.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>More can be found <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_tcp">here in the <code>tokio_tcp</code> example</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server"><a class="header" href="#server">Server</a></h1>
<p>The server API look straightforward and fairly close to that of golang's <code>net/rpc</code> package. First we should choose an async runtime and enable the <code>&quot;server&quot;</code> feature flag in our <code>Cargo.toml</code> file. Here, we will choose the <code>tokio</code> runtime be enabling the <code>&quot;tokio_runtime&quot;</code> feature flag.</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;] }
</code></pre>
<p>The next step is then to build the service instances and register the service instances onto a server which will be demonstrated below.</p>
<p>You can definitely register services that are defined with <code>#[export_impl]</code> and <code>#[export_trait]</code> on the same server. However, for simplicity and consistency with the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html">service definition chapter</a>, in the discussions below, we are going to have separate examples. If you need an example where services defined with <code>#[export_impl]</code> and <code>#[export_trait]</code> are all registered on the same server, please refer to <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-server">this</a>.</p>
<h2 id="example-with-export_impl"><a class="header" href="#example-with-export_impl">Example with <code>#[export_impl]</code></a></h2>
<p>Let's just remind ourselves that in this example the service definition and implementation are located in the same file/project, and the file structure is as follows</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Using the service we have defined and implemented in the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_impl">previous chapter</a>, we are going instantiate those services and register those instances in <code>src/bin/server.rs</code>.</p>
<pre><code class="language-rust noplaypen">// src/bin/server.rs
use tokio::net::TcpListener;
use std::sync::Arc;
use toy_rpc::Server;

// Suppose the name of this crate is &quot;example&quot;
// Let's import the two services 
use example::{Foo, Bar}; 

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let foo = Arc::new(Foo { }); // instance of &quot;Foo&quot; service
    let bar = Arc::new(Bar { }); // instance of &quot;Bar&quot; service

    // Register the services onto a server
    let server = Server::builder()
        .register(foo) // register service instance with default name &quot;Foo&quot;
        .register(bar) // register service instance with default name &quot;Bar&quot;
        .build(); // build the server

    // Open a TcpListener for incoming connections
    let listener = TcpListener::bind(addr).await.unwrap();

    // Start our server and accept incoming connections and requests
    server.accept(listener).await.unwrap();
}
</code></pre>
<h2 id="example-with-export_trait-and-export_trait_impl"><a class="header" href="#example-with-export_trait-and-export_trait_impl">Example with <code>#[export_trait]</code> and <code>#[export_trait_impl]</code></a></h2>
<p>Now we are back with the example with <code>#[export_trait]</code> and <code>#[export_trait_impl]</code>, let's just remind ourselves that we have three separate crates where the service is defined in <code>&quot;example-service&quot;</code> and will be implemented in <code>&quot;example-server&quot;</code> as shown below.</p>
<p>We will continue to use the <code>tokio</code> runtime so that we don't need to change our <code>Cargo.toml</code> file, but because we will be implementing the service below, we will need to add <code>async-trait</code> and our service definition crate into our dependencies.</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;] }

# our service definition 
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<p>Now, let's implement the service and start the server</p>
<pre><code class="language-rust noplaypen">// src/main.rs

use tokio::net::TcpListener;
use std::sync::Arc;
use async_trait::async_trait;
use toy_rpc::Server;
use toy_rpc::macros::export_trait_impl;

// Import our service definition
// Make sure you import everything to include the auto-generated helper 
// traits that allow convenient service registration
use example_service::*;

struct Abacus { }

#[async_trait]
#[export_trait_impl] // The default service name will be &quot;Arith&quot;
impl Arith for Abacus {
    // Please note that you do NOT need to mark methods with
    // `#[export_method]` another time

    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }

    fn say_hi(&amp;self) {
        println!(&quot;hi&quot;);
    }
}

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let arith = Arc::new(Abacus{}); // create an instance of the `Arith` service
    let listener = TcpListener::bind(addr).await.unwrap();
    let server = Server::builder()
        .register(arith) // register service with default name &quot;Arith&quot;
        .build();

    println!(&quot;Starting server at {}&quot;, &amp;addr);
    server.accept(listener).await.unwrap()
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server-with-async-std-runtime"><a class="header" href="#server-with-async-std-runtime">Server with <code>async-std</code> runtime</a></h1>
<p>The overall usage with <code>async-std</code> runtime should look (almost) the same as the examples before. The only difference would be </p>
<ol>
<li>add <code>async_std</code> to your dependecies</li>
<li>enable feature <code>&quot;async_std_runtime&quot;</code> as opposed to <code>&quot;tokio_runtime&quot;</code></li>
<li>use <code>async_std::net::TcpListener</code> instead of <code>tokio::net::TcpListener</code></li>
</ol>
<p>If we were to run the server with <code>async-std</code> runtime, our previous <a href="https://minghuaw.github.io/toy-rpc/04_server.html#example-with-export_trait-and-export_trait_impl"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code> example</a> would then look like the code below.</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
async-std = { version = &quot;1.9.0&quot;, features = [&quot;attributes&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;async_std_runtime&quot;, &quot;server&quot;] }

# our service definition 
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<pre><code class="language-rust noplaypen">// src/main.rs

use async_std::net::TcpListener;
use std::sync::Arc;
use async_trait::async_trait;
use toy_rpc::Server;
use toy_rpc::macros::export_trait_impl;

// Import our service definition
// Make sure you import everything to include the auto-generated helper 
// traits that allow convenient service registration
use example_service::*;

struct Abacus { }

#[async_trait]
#[export_trait_impl] // The default service name will be &quot;Arith&quot;
impl Arith for Abacus {
    // Please note that you do NOT need to mark methods with
    // `#[export_method]` another time

    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }

    fn say_hi(&amp;self) {
        println!(&quot;hi&quot;);
    }
}

#[async_std::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let arith = Arc::new(Abacus{}); // create an instance of the `Arith` service
    let listener = TcpListener::bind(addr).await.unwrap();
    let server = Server::builder()
        .register(arith) // register service with default name &quot;Arith&quot;
        .build();

    println!(&quot;Starting server at {}&quot;, &amp;addr);
    server.accept(listener).await.unwrap()
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="server-with-tokio-runtime"><a class="header" href="#server-with-tokio-runtime">Server with <code>tokio</code> runtime</a></h1>
<p>This is just going to be an identical copy of the previous <a href="https://minghuaw.github.io/toy-rpc/04_server.html#example-with-export_trait-and-export_trait_impl"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code> example</a>.</p>
<pre><code class="language-toml">[dependencies]
async-trait = &quot;0.1.50&quot;
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;net&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;] }

# our service definition 
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<pre><code class="language-rust noplaypen">// src/main.rs

use tokio::net::TcpListener;
use std::sync::Arc;
use async_trait::async_trait;
use toy_rpc::Server;
use toy_rpc::macros::export_trait_impl;

// Import our service definition
// Make sure you import everything to include the auto-generated helper 
// traits that allow convenient service registration
use example_service::*;

struct Abacus { }

#[async_trait]
#[export_trait_impl] // The default service name will be &quot;Arith&quot;
impl Arith for Abacus {
    // Please note that you do NOT need to mark methods with
    // `#[export_method]` another time

    async fn add(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 - args.1)
    }

    fn say_hi(&amp;self) {
        println!(&quot;hi&quot;);
    }
}

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let arith = Arc::new(Abacus{}); // create an instance of the `Arith` service
    let listener = TcpListener::bind(addr).await.unwrap();
    let server = Server::builder()
        .register(arith) // register service with default name &quot;Arith&quot;
        .build();

    println!(&quot;Starting server at {}&quot;, &amp;addr);
    server.accept(listener).await.unwrap()
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="integrations-with-http-server"><a class="header" href="#integrations-with-http-server">Integrations with HTTP Server</a></h1>
<p>HTTP integration is accomplished with WebSocket, and (currently) integration with three common <code>rust</code> HTTP server are supported by enabling the corresponding feature flag.</p>
<ul>
<li><code>actix-web</code>: <code>&quot;http_actix_web&quot;</code></li>
<li><code>tide</code>: <code>&quot;http_tide&quot;</code></li>
<li><code>warp</code>: <code>&quot;http_warp&quot;</code></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-integration-with-actix-web"><a class="header" href="#http-integration-with-actix-web">HTTP integration with <code>actix-web</code></a></h1>
<p>The <code>&quot;http_actix_web&quot;</code> feature flag should be toggled on to enable HTTP integration with <code>actix-web</code>. Enabling <code>&quot;http_actix_web&quot;</code> feature flag will also enable the <code>&quot;tokio_runtime&quot;</code> feature flag. </p>
<p>A convenience method <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.handle_http"><code>Server::handle_http()</code></a> is available when <code>&quot;http_actix_web&quot;</code> is the only enabled http integration feature flag. If you have multiple http integration feature flags enabled, you can use the <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.scope_config"><code>Server::scope_config</code></a> method instead (please note that you should use <code>scope_config</code> without brackets).</p>
<p>We will demonstrate the usage with a new example.</p>
<pre><code class="language-toml">[dependencies]
actix-web = &quot;3.3.2&quot;
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;http_actix_web&quot;, &quot;server&quot;] }
</code></pre>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::macros::export_impl;
use toy_rpc::Server;
use actix_web::{web, HttpServer, App};

pub struct Calculator { }

#[export_impl]
impl Calculator {
    #[export_method]
    async fn multiply(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 * args.1)
    }

    #[export_method]
    async fn divide(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 / args.1)
    }
}

#[actix_web::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let calculator = Arc::new(Calculator { });
    let server = Server::builder()
        .register(calculator)
        .build();

    let app_data = web::Data::new(server);

    HttpServer::new(
        move || {
            App::new()
                .service(
                    web::scope(&quot;/rpc/&quot;)
                        .app_data(app_data.clone())
                        .configure(Server::handle_http()) // equivalent to the line below
                        // .configure(Server::scope_config)
                )
        }
    )
    .bind(addr).unwrap()
    .run()
    .await;
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-integration-with-actix-web-1"><a class="header" href="#http-integration-with-actix-web-1">HTTP integration with <code>actix-web</code></a></h1>
<p>The <code>&quot;http_tide&quot;</code> feature flag should be toggled on to enable HTTP integration with <code>tide</code>. Enabling <code>&quot;http_tide&quot;</code> feature flag will also enable the <code>&quot;async_std_runtime&quot;</code> feature flag.</p>
<p>A convenience method <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.handle_http-1"><code>Server::handle_http(self)</code></a> is available when <code>&quot;http_tide&quot;</code> is the only http integration flag that is enabled. If multiple http integration feature flags are enabled, you can use <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.into_endpoint"><code>Server::into_endpoint(self)</code></a> method instead.</p>
<p>We will demonstrate the usage with a new example.</p>
<pre><code class="language-toml">[dependencies]
tide = &quot;0.16.0&quot;
async-std = { version = &quot;1&quot;, features = [ &quot;attributes&quot;, ] }  
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;http_tide&quot;, &quot;server&quot;] }
</code></pre>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::macros::export_impl;
use toy_rpc::Server;
use tide::prelude::*;

pub struct Calculator { }

#[export_impl]
impl Calculator {
    #[export_method]
    async fn multiply(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 * args.1)
    }

    #[export_method]
    async fn divide(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 / args.1)
    }
}

#[async_std::main]
async fn main() {
    // Get the RPC server ready
    let addr = &quot;127.0.0.1:23333&quot;;
    let calculator = Arc::new(Calculator { });
    let server = Server::builder()
        .register(calculator)
        .build();

    // Now we will work with `tide` HTTP server
    let mut app = tide::new();
    app.at(&quot;/rpc/&quot;).nest(server.handle_http());
    app.listen(addr).await.unwrap();
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-integration-with-actix-web-2"><a class="header" href="#http-integration-with-actix-web-2">HTTP integration with <code>actix-web</code></a></h1>
<p>The <code>&quot;http_warp&quot;</code> feature flag should be toggled on to enable HTTP integration with <code>warp</code> crate. Enabling <code>&quot;http_warp&quot;</code> feature flag will also enable the <code>&quot;tokio_runtime&quot;</code> featrue flag.</p>
<p>A convenience method <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.handle_http-2"><code>Server::handle_http(self)</code></a> is available when <code>&quot;http_warp&quot;</code> is the only enabled http integration feature flag. If you have multiple http integration flags enabled, you can use the <a href="https://docs.rs/toy-rpc/0.7.0-alpha.2/toy_rpc/server/struct.Server.html#method.into_boxed_filter"><code>Server::into_boxed_filter(self)</code></a> method instead.</p>
<p>We will demonstrate the usage with a new example.</p>
<pre><code class="language-toml">[dependencies]
warp = &quot;0.3.0&quot;
tokio = { version = &quot;1.4.0&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;http_warp&quot;, &quot;server&quot;] }
</code></pre>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::macros::export_impl;
use toy_rpc::Server;

pub struct Calculator { }

#[export_impl]
impl Calculator {
    #[export_method]
    async fn multiply(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 * args.1)
    }

    #[export_method]
    async fn divide(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt; {
        Ok(args.0 / args.1)
    }
}

#[tokio::main]
async fn main() {
    let calculator = Arc::new(Calculator { });
    let server = Server::builder()
        .register(calculator)
        .build();

    // Serve RPC at &quot;ws://127.0.0.1/rpc/&quot; 
    // (there is a &quot;_rpc_&quot; appended to the end of the path but the client takes care of that) 
    let routes = warp::path(&quot;rpc&quot;)
        .and(server.handle_http());
    warp::serve(routes).run(([127, 0, 0, 1], 23333)).await;
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<p>The client side usage should feel fairly close to that of the golang's <code>net/rpc</code> package as well except some changes that makes the client API more rusty and async. </p>
<p>To connect a client to a &quot;raw&quot; TCP server, you should use the <code>dial</code> function; to connect to a HTTP server, you should then use the <code>dial_http</code> function. Once you have a connected client,
you can then use the <code>call_blocking</code> and <code>call</code> methods to access the RPC functions on the server. The <code>#[export_impl]</code> and <code>#[export_trait]</code> attribute macros also generates client stub functions that allows the client to conveniently access the RPC functions without worrying about typing the wrong service or method name. </p>
<h1 id="connecting-to-tcp-server--http-server"><a class="header" href="#connecting-to-tcp-server--http-server">Connecting to TCP server / HTTP server</a></h1>
<p>For the examples below, we will assume running with the <code>tokio</code> runtime.</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;client&quot;] }
</code></pre>
<p>The example below shows how to connect to a TCP server</p>
<pre><code class="language-rust noplaypen">use toy_rpc::Client;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to server&quot;);
}
</code></pre>
<p>Connecting to the HTTP server looks very similar with some minor changes. The example below assumes that we are trying to connect to one of the <a href="https://minghuaw.github.io/toy-rpc/05_integration.html">HTTP servers</a> (all three HTTP integration examples have the RPC server serving at <code>&quot;ws://127.0.0.1:23333/rpc/&quot;</code>). Please note that there is a &quot;<em>rpc</em>&quot; appended to the end of the path by the server integration methods, but this is automatically handled by the <code>Client::dial_http</code> method so you don't need to worry about that. </p>
<pre><code class="language-rust noplaypen">use toy_rpc::Client;

#[tokio::main]
async fn main() {
    let client = Client::dial_http(&quot;ws://127.0.0.1:23333/rpc/&quot;).await
        .expect(&quot;Failed to connect to server&quot;);
}
</code></pre>
<h1 id="accessing-rpc-services"><a class="header" href="#accessing-rpc-services">Accessing RPC services</a></h1>
<h2 id="call_blocking-and-call"><a class="header" href="#call_blocking-and-call"><code>call_blocking(...)</code> and <code>call(...)</code></a></h2>
<p>There are two methods available for accessing the RPC services and methods. The <code>call_blocking</code> method blocks the execution until the response is received, and the <code>call</code> method is the asynchronous version where the execution will yield to other tasks scheduled by the runtime while waiting for the response. Cancellation is also supported on the <code>call</code> method, which is discussed with more details in the <a href="https://minghuaw.github.io/toy-rpc/06a_cancellation.html">next chapter</a>.</p>
<p>(Support of timeout is still work-in-progress. The book will be updated once the feature is implemented.)</p>
<h2 id="generated-client-stub-functions"><a class="header" href="#generated-client-stub-functions">Generated client stub functions</a></h2>
<p>The generated client stub functions internally uses the <code>call(...)</code> method and are thus async. The client stub functions consist of two steps. The first step is to access your service, and the second step is to access the method defined in that particular service. The method in the first step is always the name of the service but in snake case. For example, if you have a service <code>struct FooBar { }</code>, then the client method you use to access the service will be <code>foo_bar()</code>. The client method you use to access the method is identical to the method definition in the RPC service. For example, if an RPC method is defined as <code>fn add(&amp;self, args(i32, i32)) -&gt; Result&lt;i32, String&gt;;</code>, then the client method you use would be <code>client.bar().add((3i32, 4i32)).await;</code></p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>We will continue the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_impl"><code>#[export_impl]</code> example</a> and the [<code>#[export_trait]</code> and <code>#[export_trait_impl]</code>] example to demonstrate how to access RPC service on the server. The methods you will use to access the RPC service are the same for a TCP connection and a HTTP connection, and for simplicity, all the examples below will assume a TCP connection. For more examples on use with HTTP connections, please checkout the <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples">GitHub examples</a>.</p>
<h3 id="export_impl-1"><a class="header" href="#export_impl-1"><code>#[export_impl]</code></a></h3>
<p>Let's just remind ourselves that in this example the service definition and implementation are located in the same file/project, and the file structure is as follows</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Since the service is defined and implemented in <code>src/lib.rs</code> from the <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_impl">previous chapter</a>, we are going to include everything in the <code>src/lib.rs</code> file to allow us use the generated client stub functions in our <code>src/bin/client.rs</code>.</p>
<pre><code class="language-rust noplaypen noplaypen">use toy_rpc::Client;
use toy_rpc::Error;

// include everything from the lib.rs file
// assuming the name of the crate is &quot;example&quot;
use example::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to the server&quot;);

    // Access the remote `exported_method` method of `Foo` service in a blocking manner
    let result: Result&lt;String, Error&gt; = client.call_blocking(&quot;Foo.exported_method&quot;, ());
    println!(&quot;{:?}&quot;, result);

    // Access the remote `add` method of `Bar` service in an asynchronous manner
    let result: Result&lt;i32, Error&gt; = client.call(&quot;Bar.add&quot;, (3i32, 4i32)).await;
    println!(&quot;{:?}&quot;, result);

    // You can also use the generated client stub functions
    // Access the remote `exported_method` method of `Foo` service 
    // using the generated client stub functions
    let result = client
        .foo() // access `Foo` service
        .exported_method(()) // access `exported_method` of the `Foo` service
        .await;
    println!(&quot;{:?}&quot;, result);

    // Access the remote `add` method of `Bar` service 
    // using the generated client stub functions
    let result = client
        .bar()
        .add((3, 4))
        .await;
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<h3 id="export_trait-and-export_trait_impl-1"><a class="header" href="#export_trait-and-export_trait_impl-1"><code>#[export_trait]</code> and <code>#[export_trait_impl]</code></a></h3>
<p>Again, let's just remind ourselves that the service in this example is defined in a separate crate <a href="https://minghuaw.github.io/toy-rpc/03_define_service.html#export_trait-and-export_trait_impl"><code>example-service</code></a> and the service is implemented and served by <a href="https://minghuaw.github.io/toy-rpc/04_server.html#example-with-export_trait-and-export_trait_impl"><code>example-server</code></a> crate. What we will be doing below is to demonstrate the client, which, not surprisingly, look pretty much the same as the example above.</p>
<p>Because the service definition resides in a separate crate, we will need to import that crate as well.</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;client&quot;] }

# import our service definition, assuming we have this definition at &quot;../example-service&quot;
example-service = { version = &quot;0.1.0&quot;, path = &quot;../example-service&quot; }
</code></pre>
<pre><code class="language-rust noplaypen">use toy_rpc::{Client, Error};

// import everything to use the generated client stub functions
use example_service::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to the server&quot;);
    
    // Access the remote method `add` of service `Arith` in a blocking manner
    let result: Result&lt;i32, Error&gt; = client.call_blocking(&quot;Arith.add&quot;, (3i32, 4i32));
    println!(&quot;{:?}&quot;, result);

    // Access the remote method `subtract` of service `Arith` in an asynchronous manner
    let result: Result&lt;i32, Error&gt; = client.call(&quot;Arith.subtract&quot;, (9i32, 6i32)).await;
    println!(&quot;{:?}&quot;, result);

    // Let's use the generated client stub functions
    let result = client
        .arith() // access `Arith` service
        .add((3i32, 4i32)) // access `add` method
        .await;
    println!(&quot;{:?}&quot;, result);

    let result = client
        .arith() // access `Arith` service
        .subtract((9i32, 6i32)) // access `subtract` method
        .await;
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cancellation-of-rpc-call"><a class="header" href="#cancellation-of-rpc-call">Cancellation of RPC call</a></h1>
<p>Cancellation is supported starting from version 0.7.0-alpha.2. The client method <code>call(...)</code> returns a type <code>Call</code>, which can be either <code>.await</code>ed for the response or <code>cancel()</code>ed to stop the execution. When an RPC request is started with the method <code>call(...)</code>, the request is sent by a background task whether or not the <code>Call</code> is <code>.await</code>ed. Upon <code>cancel()</code>, the client will send a cancellation request to the server; however, it should be noted that if the client is dropped immediately after calling <code>cancel()</code>, the server may not be able to receive the cancellation request before the connection is dropped by the client.</p>
<p>Below is a simple example showing cancellation on the <code>tokio</code> runtime.In this example, we are going to define a new service with a method that simply runs in loop and sleep for a certain period of time.</p>
<p>File structure:</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Add dependencies:</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;time&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;, &quot;client&quot;] }
</code></pre>
<p>Service definition and implementation placed in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use toy_rpc::macros::export_impl;
use tokio::time;

struct Example { }

#[export_impl]
impl Example {
    #[export_method]
    async fn finite_loop(&amp;self, args: ()) -&gt; Result&lt;(), String&gt; {
        for counter in 0..500 {
            time::sleep(Duration::from_millis(500)).await;
        }
    }

    #[export_method]
    async fn echo(&amp;self, args: String) -&gt; Result&lt;String, String&gt; {
        Ok(args)
    }
}
</code></pre>
<p>Serve the RPC service with <code>src/bin/server.rs</code></p>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::Server;
use tokio::net::TcpListener;

// assume the name of the crate is &quot;example&quot;
// import service definition and implementation
use example::Example;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let ex = Arc::new(Example { });
    let server = Server::builder()
        .register(ex)
        .build()

    let listener = TcpListener::bind(addr).await.unwrap();
    server.accept(listener).await.unwrap();
}
</code></pre>
<p>On the client side, let's call the <code>finite_loop</code> RPC function and wait for two seconds and cancel it.</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use tokio::time;
use toy_rpc::client::{Client, Call};

// assume the name of the crate is &quot;example&quot;
// import service definitions and generated client stub functions
use example::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to server&quot;);

    let call: Call&lt;()&gt; = client
        .example() // access `Example` service
        .finite_loop(()); // access `finite_loop` method

    // wait for 2 seconds and cancel
    time::sleep(Duration::from_secs(2)).await;
    call.cancel();
    // You can still .await on a canceled Call, but this will return an error
    let reply = call.await;
    println!(&quot;{:?}&quot;, reply); // Err(Error::Canceled(Some(id)))

    // the `Call` type can be `.await`ed to wait for the response
    let call = client
        .example() // access `Example` service
        .echo(&quot;hello world&quot;.to_string()); // access `echo` method
    let result = call.await;
    println!(&quot;{:?}&quot;, result);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="set-timeout-for-an-rpc-call"><a class="header" href="#set-timeout-for-an-rpc-call">Set timeout for an RPC call</a></h1>
<p>A default timeout of 10 seconds is assigned to client upon creation, and this default timeout can be changed using <code>set_default_timeout(duration: Duration)</code> method on the client. Each RPC call will have the default timeout unless it is prepended with <code>set_next_timeout(..)</code> method. The client can set the timeout for the next RPC request using the <code>set_next_timeout(duration: Duration)</code> method, which can be chained with the <code>call</code> method. Please note that the timeout is <strong>ONLY</strong> set for the immediate next RPC call, and all RPC calls do not have timeout if not explicitly set using the <code>timeout</code> method.</p>
<p>We will re-use the example service definition in the <a href="https://minghuaw.github.io/toy-rpc/06a_cancellation.html">cancellation chapter</a>. For you convenience, the service definition and server code are copied below.</p>
<p>File structure:</p>
<pre><code>./src
├── /bin
│   ├── server.rs
│   ├── client.rs
└── lib.rs
</code></pre>
<p>Add dependencies:</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;rt-multi-thread&quot;, &quot;macros&quot;, &quot;time&quot;] }
toy-rpc = { version = &quot;0.7.5&quot;, features = [&quot;tokio_runtime&quot;, &quot;server&quot;, &quot;client&quot;] }
</code></pre>
<p>Service definition and implementation placed in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use toy_rpc::macros::export_impl;
use tokio::time;

struct Example { }

#[export_impl]
impl Example {
    #[export_method]
    async fn finite_loop(&amp;self, args: ()) -&gt; Result&lt;(), String&gt; {
        for counter in 0..500 {
            time::sleep(Duration::from_millis(500)).await;
        }
    }

    #[export_method]
    async fn echo(&amp;self, args: String) -&gt; Result&lt;String, String&gt; {
        Ok(args)
    }
}
</code></pre>
<p>Serve the RPC service with <code>src/bin/server.rs</code>.</p>
<pre><code class="language-rust noplaypen">use std::sync::Arc;
use toy_rpc::Server;
use tokio::net::TcpListener;

// assume the name of the crate is &quot;example&quot;
// import service definition and implementation
use example::Example;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:23333&quot;;
    let ex = Arc::new(Example { });
    let server = Server::builder()
        .register(ex)
        .build()

    let listener = TcpListener::bind(addr).await.unwrap();
    server.accept(listener).await.unwrap();
}
</code></pre>
<p>On the client side, let's call the <code>finite_loop</code> RPC function with a timeout of three seconds.</p>
<pre><code class="language-rust noplaypen">use std::time::Duration;
use tokio::time;
use toy_rpc::client::{Client, Call};

// assume the name of the crate is &quot;example&quot;
// import service definitions and generated client stub functions
use example::*;

#[tokio::main]
async fn main() {
    let client = Client::dial(&quot;127.0.0.1:23333&quot;).await
        .expect(&quot;Failed to connect to server&quot;);

    let call: Call&lt;()&gt; = client
        .set_next_timeout(Duration::from_secs(3))
        .example() // access `Example` service
        .finite_loop(()); // access `finite_loop` method
    let result = call.await; // This should give you `Err(Error::Timeout)`
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tls-support"><a class="header" href="#tls-support">TLS Support</a></h1>
<p>Support for TLS is implemented with <code>rustls</code> and its <code>async</code> derivatives <code>async-rustls</code> and <code>tokio-rustls</code>. </p>
<p>An example using a self-signed certificate can be found in the <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_tls">GitHub repo</a>.</p>
<p>More detailed documentations are underway.</p>
<h2 id="a-hrefhttpsitnextiopractical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1how-to-generate-self-signed-ca-and-certsa-an-example"><a class="header" href="#a-hrefhttpsitnextiopractical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1how-to-generate-self-signed-ca-and-certsa-an-example"><a href="https://itnext.io/practical-guide-to-securing-grpc-connections-with-go-and-tls-part-1-f63058e9d6d1">How to generate self-signed CA and certs</a> (an example)</a></h2>
<ol>
<li>Create Root signing key: <code>openssl genrsa -out ca.key 4096</code></li>
<li>Generate self-signed Root certificate: <code>openssl req -new -x509 -key ca.key -sha256 -subj &quot;/C=CA/ST=BC/L=Vancouver/O=Example, Inc.&quot; -days 365 -out ca.cert</code></li>
<li>Create a key for server: <code>openssl genrsa -out service.key 4096</code></li>
<li>Create a signing request (CSR): <code>openssl req -new -key service.key -out service.csr -config certificate.conf</code> (see section below for details of <code>certificate.conf</code>)</li>
<li>Generate a certificate for the server: <code>openssl x509 -req -in service.csr -CA ca.cert -CAkey ca.key -CAcreateserial -out service.pem -days 365 -sha256 -extfile certificate.conf -extensions req_ext</code></li>
</ol>
<p><code>certificate.conf</code></p>
<pre><code class="language-bash">[req]
default_bits = 4096
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn
[dn]
C = CA
ST = BC
L = Vancouver
O = Example, Inc.
CN = localhost
[req_ext]
subjectAltName = @alt_names
[alt_names]
DNS.1 = localhost
IP.1 = ::1
IP.2 = 127.0.0.1
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pubsub"><a class="header" href="#pubsub">PubSub</a></h1>
<p>A simple PubSub support is added in 0.8.0. A simple example can be found <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_pubsub">here</a>.</p>
<p>A publisher can be created on the server side or the client side using the <code>publisher::&lt;T: Topic&gt;()</code> method, and a subscriber can be created using the <code>subscriber::&lt;T: Topic&gt;(cap: usize)</code> method. They both take one type parameter <code>T</code> which must implement the <code>toy_rpc::pubsub::Topic</code> trait. You can use the provided derive macro <code>#[derive(toy_rpc::macros::Topic)]</code> to define a struct as the pubsub message or by manually implementing the <code>toy_rpc::pubsub::Topic</code> trait on a type.</p>
<pre><code class="language-rust noplaypen">use toy_rpc::macros::Topic;
use serde::{Serializer, Deserialize};

#[derive(Topic, Serialize, Deserialize)]
pub struct Count(pub u32);
</code></pre>
<p>The message item type and topic name can also be customized using attribute <code>#[topic]</code>. For example</p>
<pre><code class="language-rust noplaypen">#[derive(Serialize, Deserialize, Topic)
#[topic(rename=&quot;C&quot;)] // This will only change topic name to &quot;C&quot;, and the message item type is still `Count`
pub struct Count(u32);
</code></pre>
<pre><code class="language-rust noplaypen">#[derive(Topic)
#[topic(item = &quot;u32&quot;)] // This will only change the message item type
pub struct Count { }
</code></pre>
<pre><code class="language-rust noplaypen">#[derive(Topic)
#[topic(rename = &quot;C&quot;, item = &quot;u32&quot;)] // Or customize both topic name and item type
pub struct Count { }
</code></pre>
<p>Or manually implement the <code>Topic</code> trait</p>
<pre><code class="language-rust noplaypen">#[derive(Serialize, Deserialize)]
pub struct Count(pub u32);

impl toy_rpc::pubsub::Topic for Count {
    type Item = Count; // The Item type must implement `Serialize` and `Deserialize`

    // A String identifier for the topic. The user must ensure it is unique
    fn topic() -&gt; String {
        &quot;Count&quot;
    }
}
</code></pre>
<p>A publisher can be created by specifying the topic in the type parameter.</p>
<pre><code class="language-rust noplaypen">let publisher = client.publisher::&lt;Count&gt;(); // on client side
// let publisher = server.publisher::&lt;Count&gt;(); // on server side
</code></pre>
<p>The <code>Publisher</code> implements the <code>futures::Sink&lt;T&gt;</code> trait where <code>T</code> is the type parameter representing the topic. In order to publish message to the topic, the <code>futures::SinkExt</code> trait must be imported.</p>
<pre><code class="language-rust noplaypen">use futures::SinkExt;

publisher.send(Count(7)).await.unwrap();
</code></pre>
<p>A subscriber can be created by specifying the topic in the type parameter and the capacity of its local buffer. Here we will create a subscriber on the client side listening to messages on the topic <code>Count</code> with a local capacity of 10.</p>
<pre><code class="language-rust noplaypen">let subscriber = client.subscirber::&lt;Count&gt;(10).unwrap(); // on the client side
// let subscriber = server.subscriber::&lt;Count&gt;(10).unwrap(); // on the server side (except for `actix-web`)
</code></pre>
<p>The <code>Subscriber</code> implements the <code>futures::Stream&lt;Item = Result&lt;T, toy_rpc::Error&gt;&gt;</code> trait where <code>T</code> is the type parameter representing the topic. In order to process incoming messages, the <code>futures::StreamExt</code> trait must be imported.</p>
<pre><code class="language-rust noplaypen">use futures::StreamExt;

if let Some(result) = subscriber.next().await {
    let item = result.unwrap(); // There could be errors recving incoming messages
    // do something with the item
}
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_pubsub">GitHub repo</a></p>
<h2 id="ack-for-publish-message-delivery"><a class="header" href="#ack-for-publish-message-delivery"><code>Ack</code> for <code>Publish</code> message delivery</a></h2>
<p>As of version 0.8.0-beta.0, <code>Ack</code> is added in the cases where explicit <code>Ack</code> is needed. <code>Ack</code> only applies to acknowledge receiving of <code>Publish</code> message and does <em><strong>NOT</strong></em> apply to any RPC requests/responses. There are three different <code>AckMode</code></p>
<ol>
<li><code>AckModeNone</code>, which is the <em><strong>default</strong></em> mode for both the <code>Server</code> and <code>Client</code>. This mode is available on both the <code>Server</code> and the <code>Client</code> Under this mode, no <code>Ack</code> message will be required by the publisher or be sent by the subscriber.</li>
<li><code>AckModeAuto</code>. This mode is available on both the <code>Server</code> and <code>Client</code>. Under this mode, both the server and the client will automatically reply with an <code>Ack</code> to any <code>Publish</code> message they receive.</li>
<li><code>AckModeManual</code>. This mode is only available on <code>Client</code>. Under this mode, the subscriber needs to manually <code>.ack()</code> in order to get the published item. Please note that under the manual mode, the <code>Publisher</code> behaves the same as if it is under the <code>AckModeAuto</code> mode.</li>
</ol>
<p>The behavior of publisher/subscriber will be discussed in different senarios below.</p>
<ol>
<li>
<p><code>Publisher</code> on the <code>Server</code> with <code>AckModeAuto</code></p>
<p>When a <code>Publisher</code> is created on the server side, the server's pubsub handler will wait for <em><strong>ALL</strong></em> <code>Ack</code>s from the subscribers, including that from <code>Subscriber</code> on the <code>Server</code>, in an asynchronous manner, meaning the publisher is able to continue publishing new messages even if some subscribers have not sent back <code>Ack</code> yet. Upon reaching the timeout, the server's pubsub handler will try to resend the same publish message (with the same sequence ID) to the <code>Subscriber</code>s that have not send back <code>Ack</code> messages. The server will stop retrying after the maximum number of retries is reached.</p>
<p><img src="./assets/publisher_on_server.png" alt="Publisher on the Server side" /></p>
</li>
<li>
<p><code>Publisher</code> on the <code>Client</code> with <code>AckModeAuto</code> or <code>AckModeManual</code></p>
<p>When a <code>Publisher</code> is created on the client side, the client will wait for only <em><strong>ONE</strong></em> <code>Ack</code> message from the <code>Server</code> in an asynchronous manner, meaning the <code>Publisher</code> is able to continue publishing  new messages even if the <code>Ack</code> message from the <code>Server</code> has not arrived. If the <code>Ack</code> message from the <code>Server</code> does not arrive before the timeout expires, the client will attempt to publish the same message (with the same message ID). The client (<code>Publisher</code>) will stop retrying after the maximum number of retries is reached. </p>
<p>Once the <code>Publish</code> message is received by the <code>Server</code>, the message will be assigned a new sequence ID that is tracked only by the <code>Server</code>. The message will then be published to all subscribers under the topic, and the server will wait for <em><strong>ALL</strong></em> <code>Ack</code> messages from the subscribers in an asynchronous manner, meaning the server will be able to keep handling RPC requests or PubSub messages while waiting for <code>Ack</code> messages to come back. If not all <code>Ack</code> messages are sent back to the server before the timeout expires, the server will attempt to resend the same message with the same sequence ID number to the subscribers whose <code>Ack</code> messages are not received. The server will stop retrying after the maximum number of retries is reached.</p>
<p><img src="./assets/publisher_on_client.png" alt="Publisher on Client side" /></p>
</li>
<li>
<p><code>Subscriber</code> on the <code>Server</code> side with <code>AckModeAuto</code></p>
<p>Please note that the <code>Server</code> side does NOT support <code>AckModdManual</code>. Upon receiving a published message, the subscriber will automatically send back an <code>Ack</code> message to the PubSub handler on the server.</p>
</li>
<li>
<p><code>Subscriber</code> on the <code>Client</code> side with <code>AckModeAuto</code></p>
<p>Upon receiving a published message, the <code>Client</code> will automatically send back an <code>Ack</code> message back to the <code>Server</code>.</p>
</li>
<li>
<p><code>Subscriber</code> on the <code>Client</code> side with <code>AckModeManual</code></p>
<p>Instead of receiving the usual <code>Result&lt;Topic::Item, Error&gt;</code> from the <code>Subscriber</code> stream, the user will receive <code>Result&lt;Delivery&lt;Topic::Item&gt;, Error&gt;</code>. In order to get the usual <code>Topic::Item</code>, the user will need to call <code>.ack()</code> method on the <code>Delivery</code> object (ie. <code>let item = delivery.ack()</code>), which will send back an <code>Ack</code> message to the <code>Server</code>.</p>
</li>
</ol>
<h3 id="how-to-use-ackmode"><a class="header" href="#how-to-use-ackmode">How to use <code>AckMode</code></a></h3>
<p>By default, all <code>Server</code> and <code>Client</code> start with <code>AckModeNone</code></p>
<pre><code class="language-rust noplaypen">let server = Server::builder()
    .build(); // This will create a server with `AckModeNone`

let client = Client::dial(ADDR)
    .await.unwrap(); // This will create a client with `AckModeNone`
</code></pre>
<p><code>Ack</code> can be enabled by setting the <code>Server</code> or <code>Client</code> into the corresponding mode using the corresponding builder.</p>
<pre><code class="language-rust noplaypen">let server = Server::builder() // This will start the builder with `AckModeNone`
    .set_ack_mode_auto() // This will set the ServerBuilder to `AckModeAuto`
    .build(); // This will build the server with `AckModeAuto`

let client = Client::builder()
    .set_ack_mode_auto() // This will set the ClientBuilder to `AckModeAuto`
    .dial(ADDR)
    .await.unwrap(); // This will create a Client with `AckModeAuto`

let client = Client::builder() // This will start the builder with `AckModeNone`
    .set_ack_mode_manual() // This will set the ClientBuilder to `AckModeManual`
    .dial(ADDR)
    .await.unwrap(); // This will create a Client with `AckModeManual`
</code></pre>
<p>The timeout and maximum number of retries for the publisher can also be configured</p>
<pre><code class="language-rust noplaypen">let server = Server::builder()
    // Must enable Ack first
    .set_ack_mode_auto() 
    // Sets how long the server will wait for Ack messages.
    //
    // This also affects the Publish messages sent by 
    // `Publisher`s from the client side
    .set_publisher_retry_timeout(Duration::from_secs(5))  
    // Sets many times the server will retry.
    // 
    // This also affects the Publish messages sent by 
    // `Publisher`s from the client side
    .set_publisher_max_num_retries(3)
    .build();

let client = Client::builder()
    // Must set the builder into some `Ack` mode
    .set_ack_mode_auto()
    // Sets how long the client publisher will wait for Ack message from Server.
    //
    // This does ***NOT*** affect how long the server will wait for 
    // `Ack` from the subscribers
    .set_publisher_retry_timeout(Duration::from_secs(5))
    // Sets how long the client publisher will retry to send the Publish 
    // message to the server.
    //
    // This does ***NOT*** affect how many times the server will attempt to 
    // resend the publish message to the subscribers
    .set_publisher_max_num_retries(3)
    .dial(ADDR)
    .await.unwrap();
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>There are a few examples available on the <a href="https://github.com/minghuaw/toy-rpc/tree/main/examples">GitHub repo</a>. Here are some descriptions of those examples.</p>
<ul>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/async_std_tcp">&quot;Raw&quot; TCP server and client with <code>async-std</code> runtime</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tokio_tcp">&quot;Raw&quot; TCP server and client with <code>tokio</code> runtime</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/cancel_and_timeout">Cancellation and timeout of RPC call</a></li>
<li>Service definition, server implementation, and client implementation in three separate crates
<ul>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-service">service</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-server">server</a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/example-client">client</a></li>
</ul>
</li>
<li>HTTP integrations
<ul>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/actix_v3_integration"><code>actix-web</code></a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/tide_integration"><code>tide</code></a></li>
<li><a href="https://github.com/minghuaw/toy-rpc/tree/main/examples/warp_integration"><code>warp</code></a></li>
</ul>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="09-preview"><a class="header" href="#09-preview">0.9 Preview</a></h1>
<h2 id="objectives"><a class="header" href="#objectives">Objectives</a></h2>
<p>The planned objectives for 0.9 can be found in this <a href="https://github.com/minghuaw/toy-rpc/issues/25">issue</a>.</p>
<h2 id="summary-or-the-preview-releases"><a class="header" href="#summary-or-the-preview-releases">Summary or the preview releases</a></h2>
<p>More detailed information can be found in the corresponding page.</p>
<h3 id="090-alpha1"><a class="header" href="#090-alpha1">0.9.0-alpha.1</a></h3>
<p>Relaxed method return type requirements. </p>
<h3 id="090-alpha2"><a class="header" href="#090-alpha2">0.9.0-alpha.2</a></h3>
<p>Removed <code>AckMode</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="090-alpha1-1"><a class="header" href="#090-alpha1-1">0.9.0-alpha.1</a></h2>
<p>Relaxed method return type requirements. </p>
<p>Prior to this release, only <code>Result</code> type is accepted as the return type for
exported methods. Now, for methods that do not really need to be a <code>Result</code> (eg. a simple addition), the return type 
no long needs to be wrapped inside a <code>Result</code>. A more detailed example is provided below and can be found in 
this <a href="https://github.com/minghuaw/toy-rpc/tree/0.9-devel/examples/tokio_tcp">example</a>.</p>
<h3 id="service-definition"><a class="header" href="#service-definition">Service definition</a></h3>
<p>Please note that the codes that import the crates are intentionally omitted in the example below. Please refer to the 
<a href="https://github.com/minghuaw/toy-rpc/tree/0.9-devel/examples/tokio_tcp">example</a> on github for more information.</p>
<h4 id="service-definition-with-service-struct-impl"><a class="header" href="#service-definition-with-service-struct-impl">Service definition with service struct impl</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Echo { }

#[export_impl]
impl Echo {
    /// This shows an exported method that returns a non-result type
    #[export_method]
    pub async fn echo_i32(&amp;self, req: i32) -&gt; i32 {
        req
    }

    /// This shows an exported method that returns a Result type
    #[export_method]
    pub async fn echo_if_equal_to_one(&amp;self, req: i32) -&gt; Result&lt;i32, i32&gt; {
        match req {
            1 =&gt; Ok(req),
            _ =&gt; Err(req), // This will present on the client call as `Error::ExecutionError`
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<h4 id="service-definition-with-a-trait"><a class="header" href="#service-definition-with-a-trait">Service definition with a trait</a></h4>
<p>Please note that if <code>impl_for_client</code> is enabled, all the methods in the service trait <em><strong>must</strong></em> return 
a <code>Result</code> type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Here we define a trait `Arith` that comes with default implementations
/// for all of its methods
#[async_trait]
#[export_trait] 
pub trait Arith {
    /// Addition
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; i32 {
        args.0 + args.1
    }

    /// Subtraction
    #[export_method]
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; i32 {
        args.0 - args.1
    }

    /// Multiplication
    #[export_method]
    async fn multiply(&amp;self, args: (i32, i32)) -&gt; i32 {
        args.0 * args.1
    }

    /// Division. We cannot divide by zero
    #[export_method]
    async fn divide(&amp;self, args: (i32, i32)) -&gt; Result&lt;i32, String&gt; {
        let (numerator, denominator) = args;
        match denominator {
            0 =&gt; return Err(&quot;Divide by zero!&quot;.to_string()),
            _ =&gt; Ok( numerator / denominator )
        }
    }
}

/// Here we are going to define another trait (service) tha is almost 
/// identical to `Arith` shown above, but we are going to generate the trait
/// impl for the client using `impl_for_client` argument in our `#[export_trait]`
/// attribute. Plus, we will not going to supply a default implementation either.
#[async_trait]
/// All methods must be exported if client trait impl generation is enabled.
/// If `impl_for_client` is enabled, all methods in the trait must return 
/// a Result
#[export_trait(impl_for_client)]
pub trait Arith2 {
    #[export_method]
    async fn add(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt;;

    #[export_method]
    async fn subtract(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt;;

    #[export_method]
    async fn multiply(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt;;

    #[export_method]
    async fn divide(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="server-implementation"><a class="header" href="#server-implementation">Server implementation</a></h3>
<p>Nothing really changed in terms of usage for the server side. The server side example code is attached below for completeness.</p>
<pre><pre class="playground"><code class="language-rust">struct Abacus { }

/// We will simply use the default implementation provided in the trait 
/// definition for all except for add
#[async_trait]
#[export_trait_impl]
impl Arith for Abacus { 
    /// We are overriding the default implementation just for 
    /// the sake of demo
    async fn add(&amp;self, args: (i32, i32)) -&gt; i32 {
        args.0 + args.1
    }
}

/// For now, you need a separate type for a new service
struct Abacus2 { }

#[async_trait]
#[export_trait_impl]
impl Arith2 for Abacus2 {
    async fn add(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt; {
        Ok(args.0 + args.1)
    }

    async fn subtract(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt; {
        Ok(args.0 - args.1)
    }

    async fn multiply(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt; {
        Ok(args.0 * args.1)
    }

    async fn divide(&amp;self, args: (i32, i32)) -&gt; anyhow::Result&lt;i32&gt; {
        let (numerator, denominator) = args;
        match denominator {
            0 =&gt; return Err(anyhow::anyhow!(&quot;Divide by zero!&quot;)),
            _ =&gt; Ok( numerator / denominator )
        }
    }
}

#[tokio::main]
async fn main() {
    env_logger::init();

    let addr = &quot;127.0.0.1:23333&quot;;
    let echo_service = Arc::new(
        Echo { }
    );
    let arith = Arc::new(Abacus { });
    let arith2 = Arc::new(Abacus2 { });

    let server = Server::builder()
        .register(echo_service)
        .register(arith)
        .register(arith2)
        .build();

    let listener = TcpListener::bind(addr).await.unwrap();

    log::info!(&quot;Starting server at {}&quot;, &amp;addr);

    let handle = task::spawn(async move {
        server.accept(listener).await.unwrap();
    });
    handle.await.expect(&quot;Error&quot;);
}
</code></pre></pre>
<h3 id="client-side-implementation"><a class="header" href="#client-side-implementation">Client side implementation</a></h3>
<p>Like the server side implementation, there isn't much change to the client side usage. The only thing
worth mentioning is that even if the method doesn't return a <code>Result</code> in the service definition, the client
will still get a <code>Result</code> because there could be errors with connection or serialization/deserialization.</p>
<pre><pre class="playground"><code class="language-rust">
#[tokio::main]
async fn main() {
    let _ = run().await;
}

async fn run() -&gt; anyhow::Result&lt;()&gt; {
    env_logger::init();

    // Establish connection
    let addr = &quot;127.0.0.1:23333&quot;;
    let client = Client::dial(addr).await.unwrap();

    // Perform RPC using `call()` method
    let call: Call&lt;i32&gt; = client.call(&quot;Echo.echo_i32&quot;, 13i32);
    let reply = call.await?;
    println!(&quot;{:?}&quot;, reply);

    let reply: i32 = client.call(&quot;Echo.echo_i32&quot;, 1313i32).await?;
    println!(&quot;{:?}&quot;, reply);

    let ok_result = client
        .echo() // refering to `Echo` service
        .echo_if_equal_to_one(1) // refering to `echo_if_equal_to_one` method
        .await; 
    let err_result = client
        .echo()
        .echo_if_equal_to_one(2)
        .await;
    println!(&quot;Ok result: {:?}&quot;, ok_result);
    println!(&quot;Err result: {:?}&quot;, err_result);

    // Demo usage with the `Arith` trait
    let addition = client
        .arith() // generated for `Arith` service
        .add((1, 3)).await; // call `add` method
    println!(&quot;{:?}&quot;, addition);

    // Although the return type of `divide` is a `Result&lt;T, E&gt;`,
    // the execution result will be mapped to `Result&lt;T, toy_rpc::Error&gt;`
    // where `E` is mapped to `toy_rpc::Error::ExecutionError` so that 
    //   (1) the Error type doesn't need to implement `Serialize` and
    //   (2) the users don't need to unwrap twice
    let division = client
        .arith()
        .divide((3, 1)).await;
    println!(&quot;{:?}&quot;, division);

    // let's try to get an execution error
    let divide_by_zero = client
        .arith()
        .divide((3, 0)).await;
    println!(&quot;{:?}&quot;, divide_by_zero);

    // Now let's take a look at using the generated trait impl for the client.
    let addition = Arith2::add(&amp;client, (7, 8)).await;
    println!(&quot;{:?}&quot;, addition);

    let division = Arith2::divide(&amp;client, (7, 2)).await;
    println!(&quot;{:?}&quot;, division);
    let divide_by_zero = Arith2::divide(&amp;client, (7, 0)).await;
    println!(&quot;{:?}&quot;, divide_by_zero);

    client.close().await;
    Ok(())
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="removing-ackmode"><a class="header" href="#removing-ackmode">Removing <code>AckMode</code></a></h1>
<p>The <code>Ack</code> implementation wasn't particular useful under practical situations as the 
client would likely reconnect with a different port and would thus be treated as a
new client. </p>
<p>As the long term goal is to switch to some protocol like AMQP (which is another 
project that I am currently working on), proper support for message delivery 
acknowledgement can be expected when that is ready.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="change-log"><a class="header" href="#change-log">Change Log</a></h1>
<h2 id="084"><a class="header" href="#084">0.8.4</a></h2>
<ul>
<li>Unified all connection related error (read/write) to <code>Error::IoError(_)</code></li>
</ul>
<h2 id="083"><a class="header" href="#083">0.8.3</a></h2>
<ul>
<li>Reverting back to 2018 edition</li>
</ul>
<h2 id="082"><a class="header" href="#082">0.8.2</a></h2>
<ul>
<li>Fixed a bug where attribute macros doesn't parse trait path and type path correctly</li>
</ul>
<h2 id="081"><a class="header" href="#081">0.8.1</a></h2>
<ul>
<li>Updated dependencies and corresponding examples
<ul>
<li><code>axum</code> to the latest version</li>
<li>WebSocket dependencies like <code>tungstenite</code>, etc</li>
<li>TLS dependencies like <code>rustls</code>, etc.</li>
</ul>
</li>
<li>Switched from <code>async-rustls</code> to <code>futures-rustls</code></li>
<li>The error message of sending on a closed channel upon ending a client or server 
becomes a debug message now.</li>
</ul>
<h2 id="080"><a class="header" href="#080">0.8.0</a></h2>
<ul>
<li>Finalized features</li>
</ul>
<h2 id="080-beta"><a class="header" href="#080-beta">0.8.0-beta</a></h2>
<ul>
<li>Added AckMode impl</li>
<li>Added attribute #[topic()] for derive macro #[derive(Topic)]</li>
<li>Added integration with <code>axum</code></li>
</ul>
<h2 id="080-alpha"><a class="header" href="#080-alpha">0.8.0-alpha</a></h2>
<h3 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking Changes</a></h3>
<ul>
<li>Communication protocol is changed</li>
</ul>
<h3 id="non-breaking-changes"><a class="header" href="#non-breaking-changes">Non-breaking Changes</a></h3>
<ul>
<li>Added pubsub support</li>
<li>Added RPC trait implementation generation for client</li>
</ul>
<h2 id="074"><a class="header" href="#074">0.7.4</a></h2>
<ul>
<li>Fixed wrong documentation for <code>Client::with_stream&lt;T&gt;(stream: T)</code></li>
</ul>
<h2 id="del073-yankeddel"><a class="header" href="#del073-yankeddel"><del>0.7.3 (yanked)</del></a></h2>
<h2 id="072"><a class="header" href="#072">0.7.2</a></h2>
<ul>
<li>Relaxed trait bounds on generic type <code>T</code> in <code>Client::with_stream&lt;T&gt;(stream: T)</code></li>
</ul>
<h2 id="071"><a class="header" href="#071">0.7.1</a></h2>
<h3 id="bug-fix"><a class="header" href="#bug-fix">Bug fix</a></h3>
<ul>
<li>Fixed a bug where large payload is not written entirely with <code>tokio</code> runtime</li>
</ul>
<h2 id="070"><a class="header" href="#070">0.7.0</a></h2>
<h3 id="breaking-changes-1"><a class="header" href="#breaking-changes-1">Breaking Changes</a></h3>
<ul>
<li>The blocking RPC call on the client side is renamed to <code>call_blocking</code></li>
<li>The asynchronous RPC call on the client side is renamed to <code>call</code></li>
<li>The <code>call</code> method returns a <code>Call&lt;Res&gt;</code> type where <code>Res</code> represents the <code>Ok</code> type of 
result. The request is sent by a background task and thus the new <code>call</code> method is 
similar to the old <code>spawn_task</code> in terms of usage.</li>
</ul>
<h3 id="new-features"><a class="header" href="#new-features">New Features</a></h3>
<ul>
<li>Cancellation. The <code>Call&lt;Res&gt;</code> type returned by the <code>call</code> method can be canceled by 
using the <code>cancel()</code> method.</li>
<li>Timeout. A timeout can be set for the next request by calling <code>client.timeout(duration)</code>. 
only one request after setting the timeout is going to run with a timeout. If you want to set timeout
for multiple requests, you need to set the timeout for each of them.</li>
</ul>
<h2 id="061"><a class="header" href="#061">0.6.1</a></h2>
<ul>
<li>Multiple objects of the same types can be registered on the same server again, but you will need to
use the <code>ServerBuilder::register_with_name</code> method as opposed to the regular <code>ServerBuilder::register</code>.
More details can be found in <code>ServerBuilder::register_with_name</code>'s documentation.</li>
</ul>
<h2 id="060"><a class="header" href="#060">0.6.0</a></h2>
<h3 id="breaking-changes-2"><a class="header" href="#breaking-changes-2">Breaking Changes</a></h3>
<ul>
<li>In short, this update makes the crate resemble closer to the usage of <code>go</code>'s <code>net/rpc</code> package</li>
<li>Service registration is simplified to <code>Server::builder().register(foo_service).build()</code>. The examples will be
updated accordingly. Thus
<ul>
<li><code>service!()</code> macro will be deprecated</li>
<li><code>register</code> function now takes only one argument, which is the instance of the service</li>
<li>on the client side, the service name will just be the name of the struct. for example,
to call a RPC method on <code>struct Foo { }</code> service, the client simply uses
<code>.async_call(&quot;Foo.&lt;method&gt;&quot;).await</code> where <code>&lt;method&gt;</code> should be replaced with the RPC method</li>
<li>you can still register multiple services on the same server. However, only one object of the same type
can be registered on the same server. Multiple servers are needed to have multiple objects of the same type.</li>
</ul>
</li>
<li>Re-defined the custom <code>Error</code> type</li>
</ul>
<h3 id="non-breaking-changes-1"><a class="header" href="#non-breaking-changes-1">Non-breaking changes</a></h3>
<ul>
<li>Fixed bug where client does not interpret error message correctly</li>
<li>Fixed bug with <code>accept_websocket</code> crashes with incorrect protocol</li>
</ul>
<h2 id="054"><a class="header" href="#054">0.5.4</a></h2>
<ul>
<li>Handlers are now stored as a <code>fn</code> pointer as opposed to a trait object.</li>
</ul>
<h2 id="053"><a class="header" href="#053">0.5.3</a></h2>
<ul>
<li>The <code>#[export_impl]</code> macro now generates client stub functions by generating a new trait for <code>toy_rpc::Client</code>.</li>
</ul>
<h2 id="050"><a class="header" href="#050">0.5.0</a></h2>
<p><strong>Breaking changes</strong></p>
<ul>
<li>HTTP integration is now accomplished using WebSocket with <code>async_tungstenite</code>, and thus HTTP connections
of versions &lt;0.5.0 are not compatible with versions &gt;=0.5.0.</li>
<li>The custom binary transport protocol now includes a magic byte at the beginning, making
versions &lt;0.5.0 <strong>NOT</strong> compatible with versions &gt;= 0.5.0;</li>
<li><code>toy_rpc::error::Error</code> changed from struct-like variants to simple enum variants</li>
<li>Changes to feature flags
<ul>
<li>&quot;logging&quot; feature flag is removed</li>
<li>&quot;surf&quot; feature flag is removed</li>
<li>&quot;tide&quot; is changed to &quot;http_tide&quot;</li>
<li>&quot;actix-web&quot; is changed to &quot;http_actix_web&quot;</li>
<li>added &quot;http_warp&quot; feature flag</li>
<li>added &quot;async_std_runtime&quot;</li>
<li>added &quot;tokio_runtime&quot;</li>
</ul>
</li>
</ul>
<p>Non-breaking changes</p>
<ul>
<li>Removed <code>Stream</code> and <code>Sink</code> impl from the custom binary transport protocol <code>Frame</code></li>
</ul>
<h2 id="045"><a class="header" href="#045">0.4.5</a></h2>
<ul>
<li>Added <code>Sink</code> implementation for the custom binary transport protocol <code>Frame</code></li>
</ul>
<h2 id="044"><a class="header" href="#044">0.4.4</a></h2>
<ul>
<li>Modified traits <code>CodecRead</code>, <code>CodecWrite</code>, <code>ServerCodec</code>, <code>ClientCodec</code> to no longer
return number of bytes written</li>
<li>The number of bytes written for header and body will be logged separately</li>
</ul>
<h2 id="043"><a class="header" href="#043">0.4.3</a></h2>
<ul>
<li>Removed previously unused NoneError</li>
<li>Unified <code>call</code>, <code>async_call</code> and <code>spawn_task</code> for socket client
and HTTP client. The <code>call_http</code>, <code>async_call_http</code>, and <code>spawn_task_http</code>
methods are kept for compatibility.</li>
</ul>
<h2 id="042"><a class="header" href="#042">0.4.2</a></h2>
<ul>
<li>Temporary fix of <code>spawn_task()</code> and <code>spawn_task_http()</code> with <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> until
lifetime with async task is figured out. As a result, <code>Client</code> no longer needs to be declared <code>mut</code>.</li>
</ul>
<h2 id="041"><a class="header" href="#041">0.4.1</a></h2>
<ul>
<li>Updated documentation</li>
</ul>
<h2 id="040"><a class="header" href="#040">0.4.0</a></h2>
<ul>
<li>Added <code>actix-web</code> feature flag to support integration with <code>actix-web</code></li>
</ul>
<h2 id="031"><a class="header" href="#031">0.3.1</a></h2>
<ul>
<li>Added <code>serde_rmp</code> features flag</li>
<li>Updated and corrected examples in the documentation</li>
</ul>
<h2 id="030"><a class="header" href="#030">0.3.0</a></h2>
<ul>
<li>Added <code>serde_cbor</code> feature flag</li>
<li>Changed <code>bincode</code> feature flag to <code>serde_bincode</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
